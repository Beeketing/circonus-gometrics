
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/circonus-labs/circonus-gometrics/api/account.go (78.3%)</option>
				
				<option value="file1">github.com/circonus-labs/circonus-gometrics/api/acknowledgement.go (77.6%)</option>
				
				<option value="file2">github.com/circonus-labs/circonus-gometrics/api/alert.go (81.0%)</option>
				
				<option value="file3">github.com/circonus-labs/circonus-gometrics/api/annotation.go (79.1%)</option>
				
				<option value="file4">github.com/circonus-labs/circonus-gometrics/api/api.go (90.8%)</option>
				
				<option value="file5">github.com/circonus-labs/circonus-gometrics/api/broker.go (80.5%)</option>
				
				<option value="file6">github.com/circonus-labs/circonus-gometrics/api/check.go (80.5%)</option>
				
				<option value="file7">github.com/circonus-labs/circonus-gometrics/api/check_bundle.go (79.1%)</option>
				
				<option value="file8">github.com/circonus-labs/circonus-gometrics/api/check_bundle_metrics.go (75.7%)</option>
				
				<option value="file9">github.com/circonus-labs/circonus-gometrics/api/contact_group.go (79.1%)</option>
				
				<option value="file10">github.com/circonus-labs/circonus-gometrics/api/dashboard.go (79.1%)</option>
				
				<option value="file11">github.com/circonus-labs/circonus-gometrics/api/graph.go (79.1%)</option>
				
				<option value="file12">github.com/circonus-labs/circonus-gometrics/api/maintenance.go (79.1%)</option>
				
				<option value="file13">github.com/circonus-labs/circonus-gometrics/api/metric.go (77.0%)</option>
				
				<option value="file14">github.com/circonus-labs/circonus-gometrics/api/metric_cluster.go (82.6%)</option>
				
				<option value="file15">github.com/circonus-labs/circonus-gometrics/api/outlier_report.go (79.1%)</option>
				
				<option value="file16">github.com/circonus-labs/circonus-gometrics/api/provision_broker.go (75.9%)</option>
				
				<option value="file17">github.com/circonus-labs/circonus-gometrics/api/rule_set.go (79.1%)</option>
				
				<option value="file18">github.com/circonus-labs/circonus-gometrics/api/rule_set_group.go (79.1%)</option>
				
				<option value="file19">github.com/circonus-labs/circonus-gometrics/api/user.go (78.3%)</option>
				
				<option value="file20">github.com/circonus-labs/circonus-gometrics/api/worksheet.go (79.1%)</option>
				
				<option value="file21">github.com/circonus-labs/circonus-gometrics/checkmgr/broker.go (83.0%)</option>
				
				<option value="file22">github.com/circonus-labs/circonus-gometrics/checkmgr/cert.go (79.2%)</option>
				
				<option value="file23">github.com/circonus-labs/circonus-gometrics/checkmgr/check.go (79.4%)</option>
				
				<option value="file24">github.com/circonus-labs/circonus-gometrics/checkmgr/checkmgr.go (76.3%)</option>
				
				<option value="file25">github.com/circonus-labs/circonus-gometrics/checkmgr/metrics.go (98.9%)</option>
				
				<option value="file26">github.com/circonus-labs/circonus-gometrics/circonus-gometrics.go (95.7%)</option>
				
				<option value="file27">github.com/circonus-labs/circonus-gometrics/counter.go (100.0%)</option>
				
				<option value="file28">github.com/circonus-labs/circonus-gometrics/gauge.go (100.0%)</option>
				
				<option value="file29">github.com/circonus-labs/circonus-gometrics/histogram.go (100.0%)</option>
				
				<option value="file30">github.com/circonus-labs/circonus-gometrics/metrics.go (0.0%)</option>
				
				<option value="file31">github.com/circonus-labs/circonus-gometrics/submit.go (63.4%)</option>
				
				<option value="file32">github.com/circonus-labs/circonus-gometrics/text.go (100.0%)</option>
				
				<option value="file33">github.com/circonus-labs/circonus-gometrics/tools.go (0.0%)</option>
				
				<option value="file34">github.com/circonus-labs/circonus-gometrics/util.go (96.2%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">// Copyright 2016 Circonus, Inc. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Account API support - Fetch and Update
// See: https://login.circonus.com/resources/api/calls/account
// Note: Create and Delete are not supported for Accounts via the API

package api

import (
        "encoding/json"
        "fmt"
        "net/url"
        "regexp"

        "github.com/circonus-labs/circonus-gometrics/api/config"
)

// AccountLimit defines a usage limit imposed on account
type AccountLimit struct {
        Limit uint   `json:"_limit,omitempty"` // uint &gt;=0
        Type  string `json:"_type,omitempty"`  // string
        Used  uint   `json:"_used,omitempty"`  // uint &gt;=0
}

// AccountInvite defines outstanding invites
type AccountInvite struct {
        Email string `json:"email"` // string
        Role  string `json:"role"`  // string
}

// AccountUser defines current users
type AccountUser struct {
        Role    string `json:"role"` // string
        UserCID string `json:"user"` // string
}

// Account defines an account. See https://login.circonus.com/resources/api/calls/account for more information.
type Account struct {
        Address1      *string         `json:"address1,omitempty"`        // string or null
        Address2      *string         `json:"address2,omitempty"`        // string or null
        CCEmail       *string         `json:"cc_email,omitempty"`        // string or null
        CID           string          `json:"_cid,omitempty"`            // string
        City          *string         `json:"city,omitempty"`            // string or null
        ContactGroups []string        `json:"_contact_groups,omitempty"` // [] len &gt;= 0
        Country       string          `json:"country_code,omitempty"`    // string
        Description   *string         `json:"description,omitempty"`     // string or null
        Invites       []AccountInvite `json:"invites,omitempty"`         // [] len &gt;= 0
        Name          string          `json:"name,omitempty"`            // string
        OwnerCID      string          `json:"_owner,omitempty"`          // string
        StateProv     *string         `json:"state_prov,omitempty"`      // string or null
        Timezone      string          `json:"timezone,omitempty"`        // string
        UIBaseURL     string          `json:"_ui_base_url,omitempty"`    // string
        Usage         []AccountLimit  `json:"_usage,omitempty"`          // [] len &gt;= 0
        Users         []AccountUser   `json:"users,omitempty"`           // [] len &gt;= 0
}

// FetchAccount retrieves account with passed cid. Pass nil for '/account/current'.
func (a *API) FetchAccount(cid CIDType) (*Account, error) <span class="cov10" title="4">{
        var accountCID string

        if cid == nil || *cid == "" </span><span class="cov5" title="2">{
                accountCID = config.AccountPrefix + "/current"
        }</span><span class="cov5" title="2"> else {
                accountCID = string(*cid)
        }</span>

        <span class="cov10" title="4">matched, err := regexp.MatchString(config.AccountCIDRegex, accountCID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov10" title="4">if !matched </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("Invalid account CID [%s]", accountCID)
        }</span>

        <span class="cov8" title="3">result, err := a.Get(accountCID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="3">if a.Debug </span><span class="cov0" title="0">{
                a.Log.Printf("[DEBUG] account fetch, received JSON: %s", string(result))
        }</span>

        <span class="cov8" title="3">account := new(Account)
        if err := json.Unmarshal(result, account); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="3">return account, nil</span>
}

// FetchAccounts retrieves all accounts available to the API Token.
func (a *API) FetchAccounts() (*[]Account, error) <span class="cov5" title="2">{
        result, err := a.Get(config.AccountPrefix)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov5" title="2">var accounts []Account
        if err := json.Unmarshal(result, &amp;accounts); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov5" title="2">return &amp;accounts, nil</span>
}

// UpdateAccount updates passed account.
func (a *API) UpdateAccount(cfg *Account) (*Account, error) <span class="cov8" title="3">{
        if cfg == nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("Invalid account config [nil]")
        }</span>

        <span class="cov5" title="2">accountCID := string(cfg.CID)

        matched, err := regexp.MatchString(config.AccountCIDRegex, accountCID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov5" title="2">if !matched </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("Invalid account CID [%s]", accountCID)
        }</span>

        <span class="cov1" title="1">jsonCfg, err := json.Marshal(cfg)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">if a.Debug </span><span class="cov0" title="0">{
                a.Log.Printf("[DEBUG] account update, sending JSON: %s", string(jsonCfg))
        }</span>

        <span class="cov1" title="1">result, err := a.Put(accountCID, jsonCfg)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">account := &amp;Account{}
        if err := json.Unmarshal(result, account); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">return account, nil</span>
}

// SearchAccounts returns accounts matching a filter (search queries are not
// suppoted by the account endpoint). Pass nil as filter for all accounts the
// API Token can access.
func (a *API) SearchAccounts(filterCriteria *SearchFilterType) (*[]Account, error) <span class="cov5" title="2">{
        q := url.Values{}

        if filterCriteria != nil &amp;&amp; len(*filterCriteria) &gt; 0 </span><span class="cov1" title="1">{
                for filter, criteria := range *filterCriteria </span><span class="cov1" title="1">{
                        for _, val := range criteria </span><span class="cov1" title="1">{
                                q.Add(filter, val)
                        }</span>
                }
        }

        <span class="cov5" title="2">if q.Encode() == "" </span><span class="cov1" title="1">{
                return a.FetchAccounts()
        }</span>

        <span class="cov1" title="1">reqURL := url.URL{
                Path:     config.AccountPrefix,
                RawQuery: q.Encode(),
        }

        result, err := a.Get(reqURL.String())
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("[ERROR] API call error %+v", err)
        }</span>

        <span class="cov1" title="1">var accounts []Account
        if err := json.Unmarshal(result, &amp;accounts); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">return &amp;accounts, nil</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">// Copyright 2016 Circonus, Inc. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Acknowledgement API support - Fetch, Create, Update, Delete*, and Search
// See: https://login.circonus.com/resources/api/calls/acknowledgement
// *  : delete (cancel) by updating with AcknowledgedUntil set to 0

package api

import (
        "encoding/json"
        "fmt"
        "net/url"
        "regexp"

        "github.com/circonus-labs/circonus-gometrics/api/config"
)

// Acknowledgement defines a acknowledgement. See https://login.circonus.com/resources/api/calls/acknowledgement for more information.
type Acknowledgement struct {
        AcknowledgedBy    string      `json:"_acknowledged_by,omitempty"`   // string
        AcknowledgedOn    uint        `json:"_acknowledged_on,omitempty"`   // uint
        AcknowledgedUntil interface{} `json:"acknowledged_until,omitempty"` // NOTE received as uint; can be set using string or uint
        Active            bool        `json:"_active,omitempty"`            // bool
        AlertCID          string      `json:"alert,omitempty"`              // string
        CID               string      `json:"_cid,omitempty"`               // string
        LastModified      uint        `json:"_last_modified,omitempty"`     // uint
        LastModifiedBy    string      `json:"_last_modified_by,omitempty"`  // string
        Notes             string      `json:"notes,omitempty"`              // string
}

// NewAcknowledgement returns new Acknowledgement (with defaults, if applicable).
func NewAcknowledgement() *Acknowledgement <span class="cov1" title="1">{
        return &amp;Acknowledgement{}
}</span>

// FetchAcknowledgement retrieves acknowledgement with passed cid.
func (a *API) FetchAcknowledgement(cid CIDType) (*Acknowledgement, error) <span class="cov10" title="4">{
        if cid == nil || *cid == "" </span><span class="cov5" title="2">{
                return nil, fmt.Errorf("Invalid acknowledgement CID [none]")
        }</span>

        <span class="cov5" title="2">acknowledgementCID := string(*cid)

        matched, err := regexp.MatchString(config.AcknowledgementCIDRegex, acknowledgementCID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov5" title="2">if !matched </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("Invalid acknowledgement CID [%s]", acknowledgementCID)
        }</span>

        <span class="cov1" title="1">result, err := a.Get(acknowledgementCID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">if a.Debug </span><span class="cov0" title="0">{
                a.Log.Printf("[DEBUG] acknowledgement fetch, received JSON: %s", string(result))
        }</span>

        <span class="cov1" title="1">acknowledgement := &amp;Acknowledgement{}
        if err := json.Unmarshal(result, acknowledgement); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">return acknowledgement, nil</span>
}

// FetchAcknowledgements retrieves all acknowledgements available to the API Token.
func (a *API) FetchAcknowledgements() (*[]Acknowledgement, error) <span class="cov5" title="2">{
        result, err := a.Get(config.AcknowledgementPrefix)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov5" title="2">var acknowledgements []Acknowledgement
        if err := json.Unmarshal(result, &amp;acknowledgements); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov5" title="2">return &amp;acknowledgements, nil</span>
}

// UpdateAcknowledgement updates passed acknowledgement.
func (a *API) UpdateAcknowledgement(cfg *Acknowledgement) (*Acknowledgement, error) <span class="cov8" title="3">{
        if cfg == nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("Invalid acknowledgement config [nil]")
        }</span>

        <span class="cov5" title="2">acknowledgementCID := string(cfg.CID)

        matched, err := regexp.MatchString(config.AcknowledgementCIDRegex, acknowledgementCID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov5" title="2">if !matched </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("Invalid acknowledgement CID [%s]", acknowledgementCID)
        }</span>

        <span class="cov1" title="1">jsonCfg, err := json.Marshal(cfg)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">if a.Debug </span><span class="cov0" title="0">{
                a.Log.Printf("[DEBUG] acknowledgement update, sending JSON: %s", string(jsonCfg))
        }</span>

        <span class="cov1" title="1">result, err := a.Put(acknowledgementCID, jsonCfg)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">acknowledgement := &amp;Acknowledgement{}
        if err := json.Unmarshal(result, acknowledgement); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">return acknowledgement, nil</span>
}

// CreateAcknowledgement creates a new acknowledgement.
func (a *API) CreateAcknowledgement(cfg *Acknowledgement) (*Acknowledgement, error) <span class="cov5" title="2">{
        if cfg == nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("Invalid acknowledgement config [nil]")
        }</span>

        <span class="cov1" title="1">jsonCfg, err := json.Marshal(cfg)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">result, err := a.Post(config.AcknowledgementPrefix, jsonCfg)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">if a.Debug </span><span class="cov0" title="0">{
                a.Log.Printf("[DEBUG] acknowledgement create, sending JSON: %s", string(jsonCfg))
        }</span>

        <span class="cov1" title="1">acknowledgement := &amp;Acknowledgement{}
        if err := json.Unmarshal(result, acknowledgement); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">return acknowledgement, nil</span>
}

// SearchAcknowledgements returns acknowledgements matching
// the specified search query and/or filter. If nil is passed for
// both parameters all acknowledgements will be returned.
func (a *API) SearchAcknowledgements(searchCriteria *SearchQueryType, filterCriteria *SearchFilterType) (*[]Acknowledgement, error) <span class="cov10" title="4">{
        q := url.Values{}

        if searchCriteria != nil &amp;&amp; *searchCriteria != "" </span><span class="cov5" title="2">{
                q.Set("search", string(*searchCriteria))
        }</span>

        <span class="cov10" title="4">if filterCriteria != nil &amp;&amp; len(*filterCriteria) &gt; 0 </span><span class="cov5" title="2">{
                for filter, criteria := range *filterCriteria </span><span class="cov5" title="2">{
                        for _, val := range criteria </span><span class="cov5" title="2">{
                                q.Add(filter, val)
                        }</span>
                }
        }

        <span class="cov10" title="4">if q.Encode() == "" </span><span class="cov1" title="1">{
                return a.FetchAcknowledgements()
        }</span>

        <span class="cov8" title="3">reqURL := url.URL{
                Path:     config.AcknowledgementPrefix,
                RawQuery: q.Encode(),
        }

        result, err := a.Get(reqURL.String())
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("[ERROR] API call error %+v", err)
        }</span>

        <span class="cov8" title="3">var acknowledgements []Acknowledgement
        if err := json.Unmarshal(result, &amp;acknowledgements); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="3">return &amp;acknowledgements, nil</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">// Copyright 2016 Circonus, Inc. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Alert API support - Fetch and Search
// See: https://login.circonus.com/resources/api/calls/alert

package api

import (
        "encoding/json"
        "fmt"
        "net/url"
        "regexp"

        "github.com/circonus-labs/circonus-gometrics/api/config"
)

// Alert defines a alert. See https://login.circonus.com/resources/api/calls/alert for more information.
type Alert struct {
        AcknowledgementCID *string  `json:"_acknowledgement,omitempty"` // string or null
        AlertURL           string   `json:"_alert_url,omitempty"`       // string
        BrokerCID          string   `json:"_broker,omitempty"`          // string
        CheckCID           string   `json:"_check,omitempty"`           // string
        CheckName          string   `json:"_check_name,omitempty"`      // string
        CID                string   `json:"_cid,omitempty"`             // string
        ClearedOn          *uint    `json:"_cleared_on,omitempty"`      // uint or null
        ClearedValue       *string  `json:"_cleared_value,omitempty"`   // string or null
        Maintenance        []string `json:"_maintenance,omitempty"`     // [] len &gt;= 0
        MetricLinkURL      *string  `json:"_metric_link,omitempty"`     // string or null
        MetricName         string   `json:"_metric_name,omitempty"`     // string
        MetricNotes        *string  `json:"_metric_notes,omitempty"`    // string or null
        OccurredOn         uint     `json:"_occurred_on,omitempty"`     // uint
        RuleSetCID         string   `json:"_rule_set,omitempty"`        // string
        Severity           uint     `json:"_severity,omitempty"`        // uint
        Tags               []string `json:"_tags,omitempty"`            // [] len &gt;= 0
        Value              string   `json:"_value,omitempty"`           // string
}

// NewAlert returns a new alert (with defaults, if applicable)
func NewAlert() *Alert <span class="cov1" title="1">{
        return &amp;Alert{}
}</span>

// FetchAlert retrieves alert with passed cid.
func (a *API) FetchAlert(cid CIDType) (*Alert, error) <span class="cov10" title="4">{
        if cid == nil || *cid == "" </span><span class="cov5" title="2">{
                return nil, fmt.Errorf("Invalid alert CID [none]")
        }</span>

        <span class="cov5" title="2">alertCID := string(*cid)

        matched, err := regexp.MatchString(config.AlertCIDRegex, alertCID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov5" title="2">if !matched </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("Invalid alert CID [%s]", alertCID)
        }</span>

        <span class="cov1" title="1">result, err := a.Get(alertCID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">if a.Debug </span><span class="cov0" title="0">{
                a.Log.Printf("[DEBUG] fetch alert, received JSON: %s", string(result))
        }</span>

        <span class="cov1" title="1">alert := &amp;Alert{}
        if err := json.Unmarshal(result, alert); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">return alert, nil</span>
}

// FetchAlerts retrieves all alerts available to the API Token.
func (a *API) FetchAlerts() (*[]Alert, error) <span class="cov5" title="2">{
        result, err := a.Get(config.AlertPrefix)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov5" title="2">var alerts []Alert
        if err := json.Unmarshal(result, &amp;alerts); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov5" title="2">return &amp;alerts, nil</span>
}

// SearchAlerts returns alerts matching the specified search query
// and/or filter. If nil is passed for both parameters all alerts
// will be returned.
func (a *API) SearchAlerts(searchCriteria *SearchQueryType, filterCriteria *SearchFilterType) (*[]Alert, error) <span class="cov10" title="4">{
        q := url.Values{}

        if searchCriteria != nil &amp;&amp; *searchCriteria != "" </span><span class="cov5" title="2">{
                q.Set("search", string(*searchCriteria))
        }</span>

        <span class="cov10" title="4">if filterCriteria != nil &amp;&amp; len(*filterCriteria) &gt; 0 </span><span class="cov5" title="2">{
                for filter, criteria := range *filterCriteria </span><span class="cov5" title="2">{
                        for _, val := range criteria </span><span class="cov5" title="2">{
                                q.Add(filter, val)
                        }</span>
                }
        }

        <span class="cov10" title="4">if q.Encode() == "" </span><span class="cov1" title="1">{
                return a.FetchAlerts()
        }</span>

        <span class="cov8" title="3">reqURL := url.URL{
                Path:     config.AlertPrefix,
                RawQuery: q.Encode(),
        }

        result, err := a.Get(reqURL.String())
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("[ERROR] API call error %+v", err)
        }</span>

        <span class="cov8" title="3">var alerts []Alert
        if err := json.Unmarshal(result, &amp;alerts); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="3">return &amp;alerts, nil</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">// Copyright 2016 Circonus, Inc. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Annotation API support - Fetch, Create, Update, Delete, and Search
// See: https://login.circonus.com/resources/api/calls/annotation

package api

import (
        "encoding/json"
        "fmt"
        "net/url"
        "regexp"

        "github.com/circonus-labs/circonus-gometrics/api/config"
)

// Annotation defines a annotation. See https://login.circonus.com/resources/api/calls/annotation for more information.
type Annotation struct {
        Category       string   `json:"category"`                    // string
        CID            string   `json:"_cid,omitempty"`              // string
        Created        uint     `json:"_created,omitempty"`          // uint
        Description    string   `json:"description"`                 // string
        LastModified   uint     `json:"_last_modified,omitempty"`    // uint
        LastModifiedBy string   `json:"_last_modified_by,omitempty"` // string
        RelatedMetrics []string `json:"rel_metrics"`                 // [] len &gt;= 0
        Start          uint     `json:"start"`                       // uint
        Stop           uint     `json:"stop"`                        // uint
        Title          string   `json:"title"`                       // string
}

// NewAnnotation returns a new Annotation (with defaults, if applicable)
func NewAnnotation() *Annotation <span class="cov1" title="1">{
        return &amp;Annotation{}
}</span>

// FetchAnnotation retrieves annotation with passed cid.
func (a *API) FetchAnnotation(cid CIDType) (*Annotation, error) <span class="cov7" title="4">{
        if cid == nil || *cid == "" </span><span class="cov4" title="2">{
                return nil, fmt.Errorf("Invalid annotation CID [none]")
        }</span>

        <span class="cov4" title="2">annotationCID := string(*cid)

        matched, err := regexp.MatchString(config.AnnotationCIDRegex, annotationCID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov4" title="2">if !matched </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("Invalid annotation CID [%s]", annotationCID)
        }</span>

        <span class="cov1" title="1">result, err := a.Get(annotationCID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">if a.Debug </span><span class="cov0" title="0">{
                a.Log.Printf("[DEBUG] fetch annotation, received JSON: %s", string(result))
        }</span>

        <span class="cov1" title="1">annotation := &amp;Annotation{}
        if err := json.Unmarshal(result, annotation); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">return annotation, nil</span>
}

// FetchAnnotations retrieves all annotations available to the API Token.
func (a *API) FetchAnnotations() (*[]Annotation, error) <span class="cov4" title="2">{
        result, err := a.Get(config.AnnotationPrefix)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov4" title="2">var annotations []Annotation
        if err := json.Unmarshal(result, &amp;annotations); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov4" title="2">return &amp;annotations, nil</span>
}

// UpdateAnnotation updates passed annotation.
func (a *API) UpdateAnnotation(cfg *Annotation) (*Annotation, error) <span class="cov6" title="3">{
        if cfg == nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("Invalid annotation config [nil]")
        }</span>

        <span class="cov4" title="2">annotationCID := string(cfg.CID)

        matched, err := regexp.MatchString(config.AnnotationCIDRegex, annotationCID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov4" title="2">if !matched </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("Invalid annotation CID [%s]", annotationCID)
        }</span>

        <span class="cov1" title="1">jsonCfg, err := json.Marshal(cfg)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">if a.Debug </span><span class="cov0" title="0">{
                a.Log.Printf("[DEBUG] update annotation, sending JSON: %s", string(jsonCfg))
        }</span>

        <span class="cov1" title="1">result, err := a.Put(annotationCID, jsonCfg)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">annotation := &amp;Annotation{}
        if err := json.Unmarshal(result, annotation); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">return annotation, nil</span>
}

// CreateAnnotation creates a new annotation.
func (a *API) CreateAnnotation(cfg *Annotation) (*Annotation, error) <span class="cov4" title="2">{
        if cfg == nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("Invalid annotation config [nil]")
        }</span>

        <span class="cov1" title="1">jsonCfg, err := json.Marshal(cfg)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">if a.Debug </span><span class="cov0" title="0">{
                a.Log.Printf("[DEBUG] create annotation, sending JSON: %s", string(jsonCfg))
        }</span>

        <span class="cov1" title="1">result, err := a.Post(config.AnnotationPrefix, jsonCfg)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">annotation := &amp;Annotation{}
        if err := json.Unmarshal(result, annotation); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">return annotation, nil</span>
}

// DeleteAnnotation deletes passed annotation.
func (a *API) DeleteAnnotation(cfg *Annotation) (bool, error) <span class="cov6" title="3">{
        if cfg == nil </span><span class="cov1" title="1">{
                return false, fmt.Errorf("Invalid annotation config [nil]")
        }</span>

        <span class="cov4" title="2">return a.DeleteAnnotationByCID(CIDType(&amp;cfg.CID))</span>
}

// DeleteAnnotationByCID deletes annotation with passed cid.
func (a *API) DeleteAnnotationByCID(cid CIDType) (bool, error) <span class="cov10" title="6">{
        if cid == nil || *cid == "" </span><span class="cov4" title="2">{
                return false, fmt.Errorf("Invalid annotation CID [none]")
        }</span>

        <span class="cov7" title="4">annotationCID := string(*cid)

        matched, err := regexp.MatchString(config.AnnotationCIDRegex, annotationCID)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>
        <span class="cov7" title="4">if !matched </span><span class="cov4" title="2">{
                return false, fmt.Errorf("Invalid annotation CID [%s]", annotationCID)
        }</span>

        <span class="cov4" title="2">_, err = a.Delete(annotationCID)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov4" title="2">return true, nil</span>
}

// SearchAnnotations returns annotations matching the specified
// search query and/or filter. If nil is passed for both parameters
// all annotations will be returned.
func (a *API) SearchAnnotations(searchCriteria *SearchQueryType, filterCriteria *SearchFilterType) (*[]Annotation, error) <span class="cov7" title="4">{
        q := url.Values{}

        if searchCriteria != nil &amp;&amp; *searchCriteria != "" </span><span class="cov4" title="2">{
                q.Set("search", string(*searchCriteria))
        }</span>

        <span class="cov7" title="4">if filterCriteria != nil &amp;&amp; len(*filterCriteria) &gt; 0 </span><span class="cov4" title="2">{
                for filter, criteria := range *filterCriteria </span><span class="cov4" title="2">{
                        for _, val := range criteria </span><span class="cov4" title="2">{
                                q.Add(filter, val)
                        }</span>
                }
        }

        <span class="cov7" title="4">if q.Encode() == "" </span><span class="cov1" title="1">{
                return a.FetchAnnotations()
        }</span>

        <span class="cov6" title="3">reqURL := url.URL{
                Path:     config.AnnotationPrefix,
                RawQuery: q.Encode(),
        }

        result, err := a.Get(reqURL.String())
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("[ERROR] API call error %+v", err)
        }</span>

        <span class="cov6" title="3">var annotations []Annotation
        if err := json.Unmarshal(result, &amp;annotations); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov6" title="3">return &amp;annotations, nil</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">// Copyright 2016 Circonus, Inc. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package api

import (
        "bytes"
        crand "crypto/rand"
        "crypto/tls"
        "crypto/x509"
        "errors"
        "fmt"
        "io/ioutil"
        "log"
        "math"
        "math/big"
        "math/rand"
        "net"
        "net/http"
        "net/url"
        "os"
        "regexp"
        "strings"
        "sync"
        "time"

        "github.com/hashicorp/go-retryablehttp"
)

func init() <span class="cov1" title="1">{
        n, err := crand.Int(crand.Reader, big.NewInt(math.MaxInt64))
        if err != nil </span><span class="cov0" title="0">{
                rand.Seed(time.Now().UTC().UnixNano())
                return
        }</span>
        <span class="cov1" title="1">rand.Seed(n.Int64())</span>
}

const (
        // a few sensible defaults
        defaultAPIURL = "https://api.circonus.com/v2"
        defaultAPIApp = "circonus-gometrics"
        minRetryWait  = 1 * time.Second
        maxRetryWait  = 15 * time.Second
        maxRetries    = 4 // equating to 1 + maxRetries total attempts
)

// TokenKeyType - Circonus API Token key
type TokenKeyType string

// TokenAppType - Circonus API Token app name
type TokenAppType string

// TokenAccountIDType - Circonus API Token account id
type TokenAccountIDType string

// CIDType Circonus object cid
type CIDType *string

// IDType Circonus object id
type IDType int

// URLType submission url type
type URLType string

// SearchQueryType search query (see: https://login.circonus.com/resources/api#searching)
type SearchQueryType string

// SearchFilterType search filter (see: https://login.circonus.com/resources/api#filtering)
type SearchFilterType map[string][]string

// TagType search/select/custom tag(s) type
type TagType []string

// Config options for Circonus API
type Config struct {
        URL            string
        TokenKey       string
        TokenApp       string
        TokenAccountID string
        CACert         *x509.CertPool
        Log            *log.Logger
        Debug          bool
}

// API Circonus API
type API struct {
        apiURL                  *url.URL
        key                     TokenKeyType
        app                     TokenAppType
        accountID               TokenAccountIDType
        caCert                  *x509.CertPool
        Debug                   bool
        Log                     *log.Logger
        useExponentialBackoff   bool
        useExponentialBackoffmu sync.Mutex
}

// NewClient returns a new Circonus API (alias for New)
func NewClient(ac *Config) (*API, error) <span class="cov3" title="4">{
        return New(ac)
}</span>

// NewAPI returns a new Circonus API (alias for New)
func NewAPI(ac *Config) (*API, error) <span class="cov8" title="106">{
        return New(ac)
}</span>

// New returns a new Circonus API
func New(ac *Config) (*API, error) <span class="cov9" title="124">{

        if ac == nil </span><span class="cov1" title="1">{
                return nil, errors.New("Invalid API configuration (nil)")
        }</span>

        <span class="cov9" title="123">key := TokenKeyType(ac.TokenKey)
        if key == "" </span><span class="cov1" title="1">{
                return nil, errors.New("API Token is required")
        }</span>

        <span class="cov9" title="122">app := TokenAppType(ac.TokenApp)
        if app == "" </span><span class="cov2" title="2">{
                app = defaultAPIApp
        }</span>

        <span class="cov9" title="122">acctID := TokenAccountIDType(ac.TokenAccountID)

        au := string(ac.URL)
        if au == "" </span><span class="cov4" title="6">{
                au = defaultAPIURL
        }</span>
        <span class="cov9" title="122">if !strings.Contains(au, "/") </span><span class="cov1" title="1">{
                // if just a hostname is passed, ASSume "https" and a path prefix of "/v2"
                au = fmt.Sprintf("https://%s/v2", ac.URL)
        }</span>
        <span class="cov9" title="122">if last := len(au) - 1; last &gt;= 0 &amp;&amp; au[last] == '/' </span><span class="cov1" title="1">{
                // strip off trailing '/'
                au = au[:last]
        }</span>
        <span class="cov9" title="122">apiURL, err := url.Parse(au)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov9" title="121">a := &amp;API{
                apiURL:    apiURL,
                key:       key,
                app:       app,
                accountID: acctID,
                caCert:    ac.CACert,
                Debug:     ac.Debug,
                Log:       ac.Log,
                useExponentialBackoff: false,
        }

        a.Debug = ac.Debug
        a.Log = ac.Log
        if a.Debug &amp;&amp; a.Log == nil </span><span class="cov1" title="1">{
                a.Log = log.New(os.Stderr, "", log.LstdFlags)
        }</span>
        <span class="cov9" title="121">if a.Log == nil </span><span class="cov9" title="120">{
                a.Log = log.New(ioutil.Discard, "", log.LstdFlags)
        }</span>

        <span class="cov9" title="121">return a, nil</span>
}

// EnableExponentialBackoff enables use of exponential backoff for next API call(s)
// and use exponential backoff for all API calls until exponential backoff is disabled.
func (a *API) EnableExponentialBackoff() <span class="cov2" title="3">{
        a.useExponentialBackoffmu.Lock()
        a.useExponentialBackoff = true
        a.useExponentialBackoffmu.Unlock()
}</span>

// DisableExponentialBackoff disables use of exponential backoff. If a request using
// exponential backoff is currently running, it will stop using exponential backoff
// on its next iteration (if needed).
func (a *API) DisableExponentialBackoff() <span class="cov2" title="3">{
        a.useExponentialBackoffmu.Lock()
        a.useExponentialBackoff = false
        a.useExponentialBackoffmu.Unlock()
}</span>

// Get API request
func (a *API) Get(reqPath string) ([]byte, error) <span class="cov9" title="113">{
        return a.apiRequest("GET", reqPath, nil)
}</span>

// Delete API request
func (a *API) Delete(reqPath string) ([]byte, error) <span class="cov6" title="23">{
        return a.apiRequest("DELETE", reqPath, nil)
}</span>

// Post API request
func (a *API) Post(reqPath string, data []byte) ([]byte, error) <span class="cov5" title="14">{
        return a.apiRequest("POST", reqPath, data)
}</span>

// Put API request
func (a *API) Put(reqPath string, data []byte) ([]byte, error) <span class="cov5" title="18">{
        return a.apiRequest("PUT", reqPath, data)
}</span>

func backoff(interval uint) float64 <span class="cov4" title="8">{
        return math.Floor(((float64(interval) * (1 + rand.Float64())) / 2) + .5)
}</span>

// apiRequest manages retry strategy for exponential backoffs
func (a *API) apiRequest(reqMethod string, reqPath string, data []byte) ([]byte, error) <span class="cov9" title="180">{
        backoffs := []uint{2, 4, 8, 16, 32}
        attempts := 0
        success := false

        var result []byte
        var err error

        for !success </span><span class="cov9" title="188">{
                result, err = a.apiCall(reqMethod, reqPath, data)
                if err == nil </span><span class="cov9" title="176">{
                        success = true
                }</span>

                // break and return error if not using exponential backoff
                <span class="cov9" title="188">if err != nil </span><span class="cov5" title="12">{
                        if !a.useExponentialBackoff </span><span class="cov2" title="2">{
                                break</span>
                        }
                        <span class="cov4" title="10">if matched, _ := regexp.MatchString("code 403", err.Error()); matched </span><span class="cov2" title="2">{
                                break</span>
                        }
                }

                <span class="cov9" title="184">if !success </span><span class="cov4" title="8">{
                        var wait float64
                        if attempts &gt;= len(backoffs) </span><span class="cov0" title="0">{
                                wait = backoff(backoffs[len(backoffs)-1])
                        }</span><span class="cov4" title="8"> else {
                                wait = backoff(backoffs[attempts])
                        }</span>
                        <span class="cov4" title="8">attempts++
                        a.Log.Printf("[WARN] API call failed %s, retrying in %d seconds.\n", err.Error(), uint(wait))
                        time.Sleep(time.Duration(wait) * time.Second)</span>
                }
        }

        <span class="cov9" title="180">return result, err</span>
}

// apiCall call Circonus API
func (a *API) apiCall(reqMethod string, reqPath string, data []byte) ([]byte, error) <span class="cov9" title="195">{
        reqURL := a.apiURL.String()

        if reqPath == "" </span><span class="cov1" title="1">{
                return nil, errors.New("Invalid URL path")
        }</span>
        <span class="cov9" title="194">if reqPath[:1] != "/" </span><span class="cov1" title="1">{
                reqURL += "/"
        }</span>
        <span class="cov9" title="194">if len(reqPath) &gt;= 3 &amp;&amp; reqPath[:3] == "/v2" </span><span class="cov1" title="1">{
                reqURL += reqPath[3:]
        }</span><span class="cov9" title="193"> else {
                reqURL += reqPath
        }</span>

        // keep last HTTP error in the event of retry failure
        <span class="cov9" title="194">var lastHTTPError error
        retryPolicy := func(resp *http.Response, err error) (bool, error) </span><span class="cov10" title="202">{
                if err != nil </span><span class="cov0" title="0">{
                        lastHTTPError = err
                        return true, err
                }</span>
                // Check the response code. We retry on 500-range responses to allow
                // the server time to recover, as 500's are typically not permanent
                // errors and may relate to outages on the server side. This will catch
                // invalid response codes as well, like 0 and 999.
                // Retry on 429 (rate limit) as well.
                <span class="cov10" title="202">if resp.StatusCode == 0 || // wtf?!
                        resp.StatusCode &gt;= 500 || // rutroh
                        resp.StatusCode == 429 </span><span class="cov5" title="16">{ // rate limit
                        body, readErr := ioutil.ReadAll(resp.Body)
                        if readErr != nil </span><span class="cov0" title="0">{
                                lastHTTPError = fmt.Errorf("- response: %d %s", resp.StatusCode, readErr.Error())
                        }</span><span class="cov5" title="16"> else {
                                lastHTTPError = fmt.Errorf("- response: %d %s", resp.StatusCode, strings.TrimSpace(string(body)))
                        }</span>
                        <span class="cov5" title="16">return true, nil</span>
                }
                <span class="cov9" title="186">return false, nil</span>
        }

        <span class="cov9" title="194">dataReader := bytes.NewReader(data)

        req, err := retryablehttp.NewRequest(reqMethod, reqURL, dataReader)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("[ERROR] creating API request: %s %+v", reqURL, err)
        }</span>
        <span class="cov9" title="194">req.Header.Add("Accept", "application/json")
        req.Header.Add("X-Circonus-Auth-Token", string(a.key))
        req.Header.Add("X-Circonus-App-Name", string(a.app))
        if string(a.accountID) != "" </span><span class="cov4" title="6">{
                req.Header.Add("X-Circonus-Account-ID", string(a.accountID))
        }</span>

        <span class="cov9" title="194">client := retryablehttp.NewClient()
        if a.apiURL.Scheme == "https" &amp;&amp; a.caCert != nil </span><span class="cov0" title="0">{
                client.HTTPClient.Transport = &amp;http.Transport{
                        Proxy: http.ProxyFromEnvironment,
                        Dial: (&amp;net.Dialer{
                                Timeout:   30 * time.Second,
                                KeepAlive: 30 * time.Second,
                        }).Dial,
                        TLSHandshakeTimeout: 10 * time.Second,
                        TLSClientConfig:     &amp;tls.Config{RootCAs: a.caCert},
                        DisableKeepAlives:   true,
                        MaxIdleConnsPerHost: -1,
                        DisableCompression:  true,
                }
        }</span><span class="cov9" title="194"> else {
                client.HTTPClient.Transport = &amp;http.Transport{
                        Proxy: http.ProxyFromEnvironment,
                        Dial: (&amp;net.Dialer{
                                Timeout:   30 * time.Second,
                                KeepAlive: 30 * time.Second,
                        }).Dial,
                        TLSHandshakeTimeout: 10 * time.Second,
                        DisableKeepAlives:   true,
                        MaxIdleConnsPerHost: -1,
                        DisableCompression:  true,
                }
        }</span>

        <span class="cov9" title="194">a.useExponentialBackoffmu.Lock()
        eb := a.useExponentialBackoff
        a.useExponentialBackoffmu.Unlock()

        if eb </span><span class="cov5" title="14">{
                // limit to one request if using exponential backoff
                client.RetryWaitMin = 1
                client.RetryWaitMax = 2
                client.RetryMax = 0
        }</span><span class="cov9" title="180"> else {
                client.RetryWaitMin = minRetryWait
                client.RetryWaitMax = maxRetryWait
                client.RetryMax = maxRetries
        }</span>

        // retryablehttp only groks log or no log
        <span class="cov9" title="194">if a.Debug </span><span class="cov0" title="0">{
                client.Logger = a.Log
        }</span><span class="cov9" title="194"> else {
                client.Logger = log.New(ioutil.Discard, "", log.LstdFlags)
        }</span>

        <span class="cov9" title="194">client.CheckRetry = retryPolicy

        resp, err := client.Do(req)
        if err != nil </span><span class="cov4" title="8">{
                if lastHTTPError != nil </span><span class="cov4" title="8">{
                        return nil, lastHTTPError
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("[ERROR] %s: %+v", reqURL, err)</span>
        }

        <span class="cov9" title="186">defer resp.Body.Close()
        body, err := ioutil.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("[ERROR] reading response %+v", err)
        }</span>

        <span class="cov9" title="186">if resp.StatusCode &lt; 200 || resp.StatusCode &gt;= 300 </span><span class="cov3" title="4">{
                msg := fmt.Sprintf("API response code %d: %s", resp.StatusCode, string(body))
                if a.Debug </span><span class="cov0" title="0">{
                        a.Log.Printf("[DEBUG] %s\n", msg)
                }</span>

                <span class="cov3" title="4">return nil, fmt.Errorf("[ERROR] %s", msg)</span>
        }

        <span class="cov9" title="182">return body, nil</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">// Copyright 2016 Circonus, Inc. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Broker API support - Fetch and Search
// See: https://login.circonus.com/resources/api/calls/broker

package api

import (
        "encoding/json"
        "fmt"
        "net/url"
        "regexp"

        "github.com/circonus-labs/circonus-gometrics/api/config"
)

// BrokerDetail defines instance attributes
type BrokerDetail struct {
        CN           string   `json:"cn"`                       // string
        ExternalHost *string  `json:"external_host"`            // string or null
        ExternalPort uint16   `json:"external_port"`            // uint16
        IP           *string  `json:"ipaddress"`                // string or null
        MinVer       uint     `json:"minimum_version_required"` // uint
        Modules      []string `json:"modules"`                  // [] len &gt;= 0
        Port         *uint16  `json:"port"`                     // uint16 or null
        Skew         *string  `json:"skew"`                     // BUG doc: floating point number, api object: string or null
        Status       string   `json:"status"`                   // string
        Version      *uint    `json:"version"`                  // uint or null
}

// Broker defines a broker. See https://login.circonus.com/resources/api/calls/broker for more information.
type Broker struct {
        CID       string         `json:"_cid"`       // string
        Details   []BrokerDetail `json:"_details"`   // [] len &gt;= 1
        Latitude  *string        `json:"_latitude"`  // string or null
        Longitude *string        `json:"_longitude"` // string or null
        Name      string         `json:"_name"`      // string
        Tags      []string       `json:"_tags"`      // [] len &gt;= 0
        Type      string         `json:"_type"`      // string
}

// FetchBroker retrieves broker with passed cid.
func (a *API) FetchBroker(cid CIDType) (*Broker, error) <span class="cov10" title="4">{
        if cid == nil || *cid == "" </span><span class="cov5" title="2">{
                return nil, fmt.Errorf("Invalid broker CID [none]")
        }</span>

        <span class="cov5" title="2">brokerCID := string(*cid)

        matched, err := regexp.MatchString(config.BrokerCIDRegex, brokerCID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov5" title="2">if !matched </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("Invalid broker CID [%s]", brokerCID)
        }</span>

        <span class="cov1" title="1">result, err := a.Get(brokerCID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">if a.Debug </span><span class="cov0" title="0">{
                a.Log.Printf("[DEBUG] fetch broker, received JSON: %s", string(result))
        }</span>

        <span class="cov1" title="1">response := new(Broker)
        if err := json.Unmarshal(result, &amp;response); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">return response, nil</span>

}

// FetchBrokers returns all brokers available to the API Token.
func (a *API) FetchBrokers() (*[]Broker, error) <span class="cov5" title="2">{
        result, err := a.Get(config.BrokerPrefix)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov5" title="2">var response []Broker
        if err := json.Unmarshal(result, &amp;response); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov5" title="2">return &amp;response, nil</span>
}

// SearchBrokers returns brokers matching the specified search
// query and/or filter. If nil is passed for both parameters
// all brokers will be returned.
func (a *API) SearchBrokers(searchCriteria *SearchQueryType, filterCriteria *SearchFilterType) (*[]Broker, error) <span class="cov10" title="4">{
        q := url.Values{}

        if searchCriteria != nil &amp;&amp; *searchCriteria != "" </span><span class="cov5" title="2">{
                q.Set("search", string(*searchCriteria))
        }</span>

        <span class="cov10" title="4">if filterCriteria != nil &amp;&amp; len(*filterCriteria) &gt; 0 </span><span class="cov5" title="2">{
                for filter, criteria := range *filterCriteria </span><span class="cov5" title="2">{
                        for _, val := range criteria </span><span class="cov5" title="2">{
                                q.Add(filter, val)
                        }</span>
                }
        }

        <span class="cov10" title="4">if q.Encode() == "" </span><span class="cov1" title="1">{
                return a.FetchBrokers()
        }</span>

        <span class="cov8" title="3">reqURL := url.URL{
                Path:     config.BrokerPrefix,
                RawQuery: q.Encode(),
        }

        result, err := a.Get(reqURL.String())
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("[ERROR] API call error %+v", err)
        }</span>

        <span class="cov8" title="3">var brokers []Broker
        if err := json.Unmarshal(result, &amp;brokers); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="3">return &amp;brokers, nil</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">// Copyright 2016 Circonus, Inc. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Check API support - Fetch and Search
// See: https://login.circonus.com/resources/api/calls/check
// Notes: checks do not directly support create, update, and delete - see check bundle.

package api

import (
        "encoding/json"
        "fmt"
        "net/url"
        "regexp"

        "github.com/circonus-labs/circonus-gometrics/api/config"
)

// CheckDetails contains [undocumented] check type specific information
type CheckDetails map[config.Key]string

// Check defines a check. See https://login.circonus.com/resources/api/calls/check for more information.
type Check struct {
        Active         bool         `json:"_active"`       // bool
        BrokerCID      string       `json:"_broker"`       // string
        CheckBundleCID string       `json:"_check_bundle"` // string
        CheckUUID      string       `json:"_check_uuid"`   // string
        CID            string       `json:"_cid"`          // string
        Details        CheckDetails `json:"_details"`      // NOTE contents of details are check type specific, map len &gt;= 0
}

// FetchCheck retrieves check with passed cid.
func (a *API) FetchCheck(cid CIDType) (*Check, error) <span class="cov10" title="4">{
        if cid == nil || *cid == "" </span><span class="cov5" title="2">{
                return nil, fmt.Errorf("Invalid check CID [none]")
        }</span>

        <span class="cov5" title="2">checkCID := string(*cid)

        matched, err := regexp.MatchString(config.CheckCIDRegex, checkCID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov5" title="2">if !matched </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("Invalid check CID [%s]", checkCID)
        }</span>

        <span class="cov1" title="1">result, err := a.Get(checkCID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">if a.Debug </span><span class="cov0" title="0">{
                a.Log.Printf("[DEBUG] fetch check, received JSON: %s", string(result))
        }</span>

        <span class="cov1" title="1">check := new(Check)
        if err := json.Unmarshal(result, check); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">return check, nil</span>
}

// FetchChecks retrieves all checks available to the API Token.
func (a *API) FetchChecks() (*[]Check, error) <span class="cov1" title="1">{
        result, err := a.Get(config.CheckPrefix)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">var checks []Check
        if err := json.Unmarshal(result, &amp;checks); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">return &amp;checks, nil</span>
}

// SearchChecks returns checks matching the specified search query
// and/or filter. If nil is passed for both parameters all checks
// will be returned.
func (a *API) SearchChecks(searchCriteria *SearchQueryType, filterCriteria *SearchFilterType) (*[]Check, error) <span class="cov10" title="4">{
        q := url.Values{}

        if searchCriteria != nil &amp;&amp; *searchCriteria != "" </span><span class="cov5" title="2">{
                q.Set("search", string(*searchCriteria))
        }</span>

        <span class="cov10" title="4">if filterCriteria != nil &amp;&amp; len(*filterCriteria) &gt; 0 </span><span class="cov5" title="2">{
                for filter, criteria := range *filterCriteria </span><span class="cov5" title="2">{
                        for _, val := range criteria </span><span class="cov5" title="2">{
                                q.Add(filter, val)
                        }</span>
                }
        }

        <span class="cov10" title="4">if q.Encode() == "" </span><span class="cov1" title="1">{
                return a.FetchChecks()
        }</span>

        <span class="cov8" title="3">reqURL := url.URL{
                Path:     config.CheckPrefix,
                RawQuery: q.Encode(),
        }

        result, err := a.Get(reqURL.String())
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="3">var checks []Check
        if err := json.Unmarshal(result, &amp;checks); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="3">return &amp;checks, nil</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">// Copyright 2016 Circonus, Inc. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Check bundle API support - Fetch, Create, Update, Delete, and Search
// See: https://login.circonus.com/resources/api/calls/check_bundle

package api

import (
        "encoding/json"
        "fmt"
        "net/url"
        "regexp"

        "github.com/circonus-labs/circonus-gometrics/api/config"
)

// CheckBundleMetric individual metric configuration
type CheckBundleMetric struct {
        Name   string   `json:"name"`             // string
        Result *string  `json:"result,omitempty"` // string or null, NOTE not settable - return/information value only
        Status string   `json:"status,omitempty"` // string
        Tags   []string `json:"tags"`             // [] len &gt;= 0
        Type   string   `json:"type"`             // string
        Units  *string  `json:"units,omitempty"`  // string or null

}

// CheckBundleConfig contains the check type specific configuration settings
// as k/v pairs (see https://login.circonus.com/resources/api/calls/check_bundle
// for the specific settings available for each distinct check type)
type CheckBundleConfig map[config.Key]string

// CheckBundle defines a check bundle. See https://login.circonus.com/resources/api/calls/check_bundle for more information.
type CheckBundle struct {
        Brokers            []string            `json:"brokers"`                            // [] len &gt;= 0
        Checks             []string            `json:"_checks,omitempty"`                  // [] len &gt;= 0
        CheckUUIDs         []string            `json:"_check_uuids,omitempty"`             // [] len &gt;= 0
        CID                string              `json:"_cid,omitempty"`                     // string
        Config             CheckBundleConfig   `json:"config"`                             // NOTE contents of config are check type specific, map len &gt;= 0
        Created            uint                `json:"_created,omitempty"`                 // uint
        DisplayName        string              `json:"display_name"`                       // string
        LastModifedBy      string              `json:"_last_modifed_by,omitempty"`         // string
        LastModified       uint                `json:"_last_modified,omitempty"`           // uint
        MetricLimit        int                 `json:"metric_limit,omitempty"`             // int
        Metrics            []CheckBundleMetric `json:"metrics"`                            // [] &gt;= 0
        Notes              *string             `json:"notes,omitempty"`                    // string or null
        Period             uint                `json:"period,omitempty"`                   // uint
        ReverseConnectURLs []string            `json:"_reverse_connection_urls,omitempty"` // [] len &gt;= 0
        Status             string              `json:"status,omitempty"`                   // string
        Tags               []string            `json:"tags,omitempty"`                     // [] len &gt;= 0
        Target             string              `json:"target"`                             // string
        Timeout            float32             `json:"timeout,omitempty"`                  // float32
        Type               string              `json:"type"`                               // string
}

// NewCheckBundle returns new CheckBundle (with defaults, if applicable)
func NewCheckBundle() *CheckBundle <span class="cov1" title="1">{
        return &amp;CheckBundle{
                Config:      make(CheckBundleConfig, config.DefaultConfigOptionsSize),
                MetricLimit: config.DefaultCheckBundleMetricLimit,
                Period:      config.DefaultCheckBundlePeriod,
                Timeout:     config.DefaultCheckBundleTimeout,
                Status:      config.DefaultCheckBundleStatus,
        }
}</span>

// FetchCheckBundle retrieves check bundle with passed cid.
func (a *API) FetchCheckBundle(cid CIDType) (*CheckBundle, error) <span class="cov7" title="4">{
        if cid == nil || *cid == "" </span><span class="cov4" title="2">{
                return nil, fmt.Errorf("Invalid check bundle CID [none]")
        }</span>

        <span class="cov4" title="2">bundleCID := string(*cid)

        matched, err := regexp.MatchString(config.CheckBundleCIDRegex, bundleCID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov4" title="2">if !matched </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("Invalid check bundle CID [%v]", bundleCID)
        }</span>

        <span class="cov1" title="1">result, err := a.Get(bundleCID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">if a.Debug </span><span class="cov0" title="0">{
                a.Log.Printf("[DEBUG] fetch check bundle, received JSON: %s", string(result))
        }</span>

        <span class="cov1" title="1">checkBundle := &amp;CheckBundle{}
        if err := json.Unmarshal(result, checkBundle); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">return checkBundle, nil</span>
}

// FetchCheckBundles retrieves all check bundles available to the API Token.
func (a *API) FetchCheckBundles() (*[]CheckBundle, error) <span class="cov1" title="1">{
        result, err := a.Get(config.CheckBundlePrefix)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">var checkBundles []CheckBundle
        if err := json.Unmarshal(result, &amp;checkBundles); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">return &amp;checkBundles, nil</span>
}

// UpdateCheckBundle updates passed check bundle.
func (a *API) UpdateCheckBundle(cfg *CheckBundle) (*CheckBundle, error) <span class="cov6" title="3">{
        if cfg == nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("Invalid check bundle config [nil]")
        }</span>

        <span class="cov4" title="2">bundleCID := string(cfg.CID)

        matched, err := regexp.MatchString(config.CheckBundleCIDRegex, bundleCID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov4" title="2">if !matched </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("Invalid check bundle CID [%s]", bundleCID)
        }</span>

        <span class="cov1" title="1">jsonCfg, err := json.Marshal(cfg)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">if a.Debug </span><span class="cov0" title="0">{
                a.Log.Printf("[DEBUG] update check bundle, sending JSON: %s", string(jsonCfg))
        }</span>

        <span class="cov1" title="1">result, err := a.Put(bundleCID, jsonCfg)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">checkBundle := &amp;CheckBundle{}
        if err := json.Unmarshal(result, checkBundle); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">return checkBundle, nil</span>
}

// CreateCheckBundle creates a new check bundle (check).
func (a *API) CreateCheckBundle(cfg *CheckBundle) (*CheckBundle, error) <span class="cov4" title="2">{
        if cfg == nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("Invalid check bundle config [nil]")
        }</span>

        <span class="cov1" title="1">jsonCfg, err := json.Marshal(cfg)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">if a.Debug </span><span class="cov0" title="0">{
                a.Log.Printf("[DEBUG] create check bundle, sending JSON: %s", string(jsonCfg))
        }</span>

        <span class="cov1" title="1">result, err := a.Post(config.CheckBundlePrefix, jsonCfg)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">checkBundle := &amp;CheckBundle{}
        if err := json.Unmarshal(result, checkBundle); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">return checkBundle, nil</span>
}

// DeleteCheckBundle deletes passed check bundle.
func (a *API) DeleteCheckBundle(cfg *CheckBundle) (bool, error) <span class="cov6" title="3">{
        if cfg == nil </span><span class="cov1" title="1">{
                return false, fmt.Errorf("Invalid check bundle config [nil]")
        }</span>
        <span class="cov4" title="2">return a.DeleteCheckBundleByCID(CIDType(&amp;cfg.CID))</span>
}

// DeleteCheckBundleByCID deletes check bundle with passed cid.
func (a *API) DeleteCheckBundleByCID(cid CIDType) (bool, error) <span class="cov10" title="6">{

        if cid == nil || *cid == "" </span><span class="cov4" title="2">{
                return false, fmt.Errorf("Invalid check bundle CID [none]")
        }</span>

        <span class="cov7" title="4">bundleCID := string(*cid)

        matched, err := regexp.MatchString(config.CheckBundleCIDRegex, bundleCID)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>
        <span class="cov7" title="4">if !matched </span><span class="cov4" title="2">{
                return false, fmt.Errorf("Invalid check bundle CID [%v]", bundleCID)
        }</span>

        <span class="cov4" title="2">_, err = a.Delete(bundleCID)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov4" title="2">return true, nil</span>
}

// SearchCheckBundles returns check bundles matching the specified
// search query and/or filter. If nil is passed for both parameters
// all check bundles will be returned.
func (a *API) SearchCheckBundles(searchCriteria *SearchQueryType, filterCriteria *map[string][]string) (*[]CheckBundle, error) <span class="cov7" title="4">{

        q := url.Values{}

        if searchCriteria != nil &amp;&amp; *searchCriteria != "" </span><span class="cov4" title="2">{
                q.Set("search", string(*searchCriteria))
        }</span>

        <span class="cov7" title="4">if filterCriteria != nil &amp;&amp; len(*filterCriteria) &gt; 0 </span><span class="cov4" title="2">{
                for filter, criteria := range *filterCriteria </span><span class="cov4" title="2">{
                        for _, val := range criteria </span><span class="cov4" title="2">{
                                q.Add(filter, val)
                        }</span>
                }
        }

        <span class="cov7" title="4">if q.Encode() == "" </span><span class="cov1" title="1">{
                return a.FetchCheckBundles()
        }</span>

        <span class="cov6" title="3">reqURL := url.URL{
                Path:     config.CheckBundlePrefix,
                RawQuery: q.Encode(),
        }

        resp, err := a.Get(reqURL.String())
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("[ERROR] API call error %+v", err)
        }</span>

        <span class="cov6" title="3">var results []CheckBundle
        if err := json.Unmarshal(resp, &amp;results); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov6" title="3">return &amp;results, nil</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">// Copyright 2016 Circonus, Inc. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// CheckBundleMetrics API support - Fetch, Create*, Update, and Delete**
// See: https://login.circonus.com/resources/api/calls/check_bundle_metrics
// *  : create metrics by adding to array with a status of 'active'
// ** : delete (distable collection of) metrics by changing status from 'active' to 'available'

package api

import (
        "encoding/json"
        "fmt"
        "regexp"

        "github.com/circonus-labs/circonus-gometrics/api/config"
)

// CheckBundleMetrics defines metrics for a specific check bundle. See https://login.circonus.com/resources/api/calls/check_bundle_metrics for more information.
type CheckBundleMetrics struct {
        CID     string              `json:"_cid,omitempty"` // string
        Metrics []CheckBundleMetric `json:"metrics"`        // See check_bundle.go for CheckBundleMetric definition
}

// FetchCheckBundleMetrics retrieves metrics for the check bundle with passed cid.
func (a *API) FetchCheckBundleMetrics(cid CIDType) (*CheckBundleMetrics, error) <span class="cov10" title="4">{
        if cid == nil || *cid == "" </span><span class="cov5" title="2">{
                return nil, fmt.Errorf("Invalid check bundle metrics CID [none]")
        }</span>

        <span class="cov5" title="2">metricsCID := string(*cid)

        matched, err := regexp.MatchString(config.CheckBundleMetricsCIDRegex, metricsCID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov5" title="2">if !matched </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("Invalid check bundle metrics CID [%s]", metricsCID)
        }</span>

        <span class="cov1" title="1">result, err := a.Get(metricsCID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">if a.Debug </span><span class="cov0" title="0">{
                a.Log.Printf("[DEBUG] fetch check bundle metrics, received JSON: %s", string(result))
        }</span>

        <span class="cov1" title="1">metrics := &amp;CheckBundleMetrics{}
        if err := json.Unmarshal(result, metrics); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">return metrics, nil</span>
}

// UpdateCheckBundleMetrics updates passed metrics.
func (a *API) UpdateCheckBundleMetrics(cfg *CheckBundleMetrics) (*CheckBundleMetrics, error) <span class="cov8" title="3">{
        if cfg == nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("Invalid check bundle metrics config [nil]")
        }</span>

        <span class="cov5" title="2">metricsCID := string(cfg.CID)

        matched, err := regexp.MatchString(config.CheckBundleMetricsCIDRegex, metricsCID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov5" title="2">if !matched </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("Invalid check bundle metrics CID [%s]", metricsCID)
        }</span>

        <span class="cov1" title="1">jsonCfg, err := json.Marshal(cfg)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">if a.Debug </span><span class="cov0" title="0">{
                a.Log.Printf("[DEBUG] update check bundle metrics, sending JSON: %s", string(jsonCfg))
        }</span>

        <span class="cov1" title="1">result, err := a.Put(metricsCID, jsonCfg)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">metrics := &amp;CheckBundleMetrics{}
        if err := json.Unmarshal(result, metrics); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">return metrics, nil</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">// Copyright 2016 Circonus, Inc. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Contact Group API support - Fetch, Create, Update, Delete, and Search
// See: https://login.circonus.com/resources/api/calls/contact_group

package api

import (
        "encoding/json"
        "fmt"
        "net/url"
        "regexp"

        "github.com/circonus-labs/circonus-gometrics/api/config"
)

// ContactGroupAlertFormats define alert formats
type ContactGroupAlertFormats struct {
        LongMessage  *string `json:"long_message"`  // string or null
        LongSubject  *string `json:"long_subject"`  // string or null
        LongSummary  *string `json:"long_summary"`  // string or null
        ShortMessage *string `json:"short_message"` // string or null
        ShortSummary *string `json:"short_summary"` // string or null
}

// ContactGroupContactsExternal external contacts
type ContactGroupContactsExternal struct {
        Info   string `json:"contact_info"` // string
        Method string `json:"method"`       // string
}

// ContactGroupContactsUser user contacts
type ContactGroupContactsUser struct {
        Info    string `json:"_contact_info,omitempty"` // string
        Method  string `json:"method"`                  // string
        UserCID string `json:"user"`                    // string
}

// ContactGroupContacts list of contacts
type ContactGroupContacts struct {
        External []ContactGroupContactsExternal `json:"external"` // [] len &gt;= 0
        Users    []ContactGroupContactsUser     `json:"users"`    // [] len &gt;= 0
}

// ContactGroupEscalation defines escalations for severity levels
type ContactGroupEscalation struct {
        After           uint   `json:"after"`         // uint
        ContactGroupCID string `json:"contact_group"` // string
}

// ContactGroup defines a contact group. See https://login.circonus.com/resources/api/calls/contact_group for more information.
type ContactGroup struct {
        AggregationWindow uint                      `json:"aggregation_window,omitempty"` // uint
        AlertFormats      ContactGroupAlertFormats  `json:"alert_formats,omitempty"`      // ContactGroupAlertFormats
        CID               string                    `json:"_cid,omitempty"`               // string
        Contacts          ContactGroupContacts      `json:"contacts,omitempty"`           // ContactGroupContacts
        Escalations       []*ContactGroupEscalation `json:"escalations,omitempty"`        // [] len == 5, elements: ContactGroupEscalation or null
        LastModified      uint                      `json:"_last_modified,omitempty"`     // uint
        LastModifiedBy    string                    `json:"_last_modified_by,omitempty"`  // string
        Name              string                    `json:"name,omitempty"`               // string
        Reminders         []uint                    `json:"reminders,omitempty"`          // [] len == 5
        Tags              []string                  `json:"tags,omitempty"`               // [] len &gt;= 0
}

// NewContactGroup returns a ContactGroup (with defaults, if applicable)
func NewContactGroup() *ContactGroup <span class="cov1" title="1">{
        return &amp;ContactGroup{
                Escalations: make([]*ContactGroupEscalation, config.NumSeverityLevels),
                Reminders:   make([]uint, config.NumSeverityLevels),
                Contacts: ContactGroupContacts{
                        External: []ContactGroupContactsExternal{},
                        Users:    []ContactGroupContactsUser{},
                },
        }
}</span>

// FetchContactGroup retrieves contact group with passed cid.
func (a *API) FetchContactGroup(cid CIDType) (*ContactGroup, error) <span class="cov7" title="4">{
        if cid == nil || *cid == "" </span><span class="cov4" title="2">{
                return nil, fmt.Errorf("Invalid contact group CID [none]")
        }</span>

        <span class="cov4" title="2">groupCID := string(*cid)

        matched, err := regexp.MatchString(config.ContactGroupCIDRegex, groupCID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov4" title="2">if !matched </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("Invalid contact group CID [%s]", groupCID)
        }</span>

        <span class="cov1" title="1">result, err := a.Get(groupCID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">if a.Debug </span><span class="cov0" title="0">{
                a.Log.Printf("[DEBUG] fetch contact group, received JSON: %s", string(result))
        }</span>

        <span class="cov1" title="1">group := new(ContactGroup)
        if err := json.Unmarshal(result, group); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">return group, nil</span>
}

// FetchContactGroups retrieves all contact groups available to the API Token.
func (a *API) FetchContactGroups() (*[]ContactGroup, error) <span class="cov4" title="2">{
        result, err := a.Get(config.ContactGroupPrefix)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov4" title="2">var groups []ContactGroup
        if err := json.Unmarshal(result, &amp;groups); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov4" title="2">return &amp;groups, nil</span>
}

// UpdateContactGroup updates passed contact group.
func (a *API) UpdateContactGroup(cfg *ContactGroup) (*ContactGroup, error) <span class="cov6" title="3">{
        if cfg == nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("Invalid contact group config [nil]")
        }</span>

        <span class="cov4" title="2">groupCID := string(cfg.CID)

        matched, err := regexp.MatchString(config.ContactGroupCIDRegex, groupCID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov4" title="2">if !matched </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("Invalid contact group CID [%s]", groupCID)
        }</span>

        <span class="cov1" title="1">jsonCfg, err := json.Marshal(cfg)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">if a.Debug </span><span class="cov0" title="0">{
                a.Log.Printf("[DEBUG] update contact group, sending JSON: %s", string(jsonCfg))
        }</span>

        <span class="cov1" title="1">result, err := a.Put(groupCID, jsonCfg)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">group := &amp;ContactGroup{}
        if err := json.Unmarshal(result, group); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">return group, nil</span>
}

// CreateContactGroup creates a new contact group.
func (a *API) CreateContactGroup(cfg *ContactGroup) (*ContactGroup, error) <span class="cov4" title="2">{
        if cfg == nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("Invalid contact group config [nil]")
        }</span>

        <span class="cov1" title="1">jsonCfg, err := json.Marshal(cfg)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">if a.Debug </span><span class="cov0" title="0">{
                a.Log.Printf("[DEBUG] create contact group, sending JSON: %s", string(jsonCfg))
        }</span>

        <span class="cov1" title="1">result, err := a.Post(config.ContactGroupPrefix, jsonCfg)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">group := &amp;ContactGroup{}
        if err := json.Unmarshal(result, group); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">return group, nil</span>
}

// DeleteContactGroup deletes passed contact group.
func (a *API) DeleteContactGroup(cfg *ContactGroup) (bool, error) <span class="cov6" title="3">{
        if cfg == nil </span><span class="cov1" title="1">{
                return false, fmt.Errorf("Invalid contact group config [nil]")
        }</span>
        <span class="cov4" title="2">return a.DeleteContactGroupByCID(CIDType(&amp;cfg.CID))</span>
}

// DeleteContactGroupByCID deletes contact group with passed cid.
func (a *API) DeleteContactGroupByCID(cid CIDType) (bool, error) <span class="cov10" title="6">{
        if cid == nil || *cid == "" </span><span class="cov4" title="2">{
                return false, fmt.Errorf("Invalid contact group CID [none]")
        }</span>

        <span class="cov7" title="4">groupCID := string(*cid)

        matched, err := regexp.MatchString(config.ContactGroupCIDRegex, groupCID)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>
        <span class="cov7" title="4">if !matched </span><span class="cov4" title="2">{
                return false, fmt.Errorf("Invalid contact group CID [%s]", groupCID)
        }</span>

        <span class="cov4" title="2">_, err = a.Delete(groupCID)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov4" title="2">return true, nil</span>
}

// SearchContactGroups returns contact groups matching the specified
// search query and/or filter. If nil is passed for both parameters
// all contact groups will be returned.
func (a *API) SearchContactGroups(searchCriteria *SearchQueryType, filterCriteria *SearchFilterType) (*[]ContactGroup, error) <span class="cov7" title="4">{
        q := url.Values{}

        if searchCriteria != nil &amp;&amp; *searchCriteria != "" </span><span class="cov4" title="2">{
                q.Set("search", string(*searchCriteria))
        }</span>

        <span class="cov7" title="4">if filterCriteria != nil &amp;&amp; len(*filterCriteria) &gt; 0 </span><span class="cov4" title="2">{
                for filter, criteria := range *filterCriteria </span><span class="cov4" title="2">{
                        for _, val := range criteria </span><span class="cov4" title="2">{
                                q.Add(filter, val)
                        }</span>
                }
        }

        <span class="cov7" title="4">if q.Encode() == "" </span><span class="cov1" title="1">{
                return a.FetchContactGroups()
        }</span>

        <span class="cov6" title="3">reqURL := url.URL{
                Path:     config.ContactGroupPrefix,
                RawQuery: q.Encode(),
        }

        result, err := a.Get(reqURL.String())
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("[ERROR] API call error %+v", err)
        }</span>

        <span class="cov6" title="3">var groups []ContactGroup
        if err := json.Unmarshal(result, &amp;groups); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov6" title="3">return &amp;groups, nil</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">// Copyright 2016 Circonus, Inc. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Dashboard API support - Fetch, Create, Update, Delete, and Search
// See: https://login.circonus.com/resources/api/calls/dashboard

package api

import (
        "encoding/json"
        "fmt"
        "net/url"
        "regexp"

        "github.com/circonus-labs/circonus-gometrics/api/config"
)

// DashboardGridLayout defines layout
type DashboardGridLayout struct {
        Height uint `json:"height"`
        Width  uint `json:"width"`
}

// DashboardAccessConfig defines access config
type DashboardAccessConfig struct {
        BlackDash           bool   `json:"black_dash,omitempty"`
        Enabled             bool   `json:"enabled,omitempty"`
        Fullscreen          bool   `json:"fullscreen,omitempty"`
        FullscreenHideTitle bool   `json:"fullscreen_hide_title,omitempty"`
        Nickname            string `json:"nickname,omitempty"`
        ScaleText           bool   `json:"scale_text,omitempty"`
        SharedID            string `json:"shared_id,omitempty"`
        TextSize            uint   `json:"text_size,omitempty"`
}

// DashboardOptions defines options
type DashboardOptions struct {
        AccessConfigs       []DashboardAccessConfig `json:"access_configs,omitempty"`
        FullscreenHideTitle bool                    `json:"fullscreen_hide_title,omitempty"`
        HideGrid            bool                    `json:"hide_grid,omitempty"`
        Linkages            [][]string              `json:"linkages,omitempty"`
        ScaleText           bool                    `json:"scale_text,omitempty"`
        TextSize            uint                    `json:"text_size,omitempty"`
}

// ChartTextWidgetDatapoint defines datapoints for charts
type ChartTextWidgetDatapoint struct {
        AccountID    string `json:"account_id,omitempty"`     // metric cluster, metric
        CheckID      uint   `json:"_check_id,omitempty"`      // metric
        ClusterID    uint   `json:"cluster_id,omitempty"`     // metric cluster
        ClusterTitle string `json:"_cluster_title,omitempty"` // metric cluster
        Label        string `json:"label,omitempty"`          // metric
        Label2       string `json:"_label,omitempty"`         // metric cluster
        Metric       string `json:"metric,omitempty"`         // metric
        MetricType   string `json:"_metric_type,omitempty"`   // metric
        NumericOnly  bool   `json:"numeric_only,omitempty"`   // metric cluster
}

// ChartWidgetDefinitionLegend defines chart widget definition legend
type ChartWidgetDefinitionLegend struct {
        Show bool   `json:"show,omitempty"`
        Type string `json:"type,omitempty"`
}

// ChartWidgetWedgeLabels defines chart widget wedge labels
type ChartWidgetWedgeLabels struct {
        OnChart  bool `json:"on_chart,omitempty"`
        ToolTips bool `json:"tooltips,omitempty"`
}

// ChartWidgetWedgeValues defines chart widget wedge values
type ChartWidgetWedgeValues struct {
        Angle string `json:"angle,omitempty"`
        Color string `json:"color,omitempty"`
        Show  bool   `json:"show,omitempty"`
}

// ChartWidgtDefinition defines chart widget definition
type ChartWidgtDefinition struct {
        Datasource        string                      `json:"datasource,omitempty"`
        Derive            string                      `json:"derive,omitempty"`
        DisableAutoformat bool                        `json:"disable_autoformat,omitempty"`
        Formula           string                      `json:"formula,omitempty"`
        Legend            ChartWidgetDefinitionLegend `json:"legend,omitempty"`
        Period            uint                        `json:"period,omitempty"`
        PopOnHover        bool                        `json:"pop_onhover,omitempty"`
        WedgeLabels       ChartWidgetWedgeLabels      `json:"wedge_labels,omitempty"`
        WedgeValues       ChartWidgetWedgeValues      `json:"wedge_values,omitempty"`
}

// ForecastGaugeWidgetThresholds defines forecast widget thresholds
type ForecastGaugeWidgetThresholds struct {
        Colors []string `json:"colors,omitempty"` // forecasts, gauges
        Flip   bool     `json:"flip,omitempty"`   // gauges
        Values []string `json:"values,omitempty"` // forecasts, gauges
}

// StatusWidgetAgentStatusSettings defines agent status settings
type StatusWidgetAgentStatusSettings struct {
        Search         string `json:"search,omitempty"`
        ShowAgentTypes string `json:"show_agent_types,omitempty"`
        ShowContact    bool   `json:"show_contact,omitempty"`
        ShowFeeds      bool   `json:"show_feeds,omitempty"`
        ShowSetup      bool   `json:"show_setup,omitempty"`
        ShowSkew       bool   `json:"show_skew,omitempty"`
        ShowUpdates    bool   `json:"show_updates,omitempty"`
}

// StatusWidgetHostStatusSettings defines host status settings
type StatusWidgetHostStatusSettings struct {
        LayoutStyle  string   `json:"layout_style,omitempty"`
        Search       string   `json:"search,omitempty"`
        SortBy       string   `json:"sort_by,omitempty"`
        TagFilterSet []string `json:"tag_filter_set,omitempty"`
}

// DashboardWidgetSettings defines settings specific to widget
type DashboardWidgetSettings struct {
        AccountID           string                          `json:"account_id,omitempty"`            // alerts, clusters, gauges, graphs, lists, status
        Acknowledged        string                          `json:"acknowledged,omitempty"`          // alerts
        AgentStatusSettings StatusWidgetAgentStatusSettings `json:"agent_status_settings,omitempty"` // status
        Algorithm           string                          `json:"algorithm,omitempty"`             // clusters
        Autoformat          bool                            `json:"autoformat,omitempty"`            // text
        BodyFormat          string                          `json:"body_format,omitempty"`           // text
        ChartType           string                          `json:"chart_type,omitempty"`            // charts
        CheckUUID           string                          `json:"check_uuid,omitempty"`            // gauges
        Cleared             string                          `json:"cleared,omitempty"`               // alerts
        ClusterID           uint                            `json:"cluster_id,omitempty"`            // clusters
        ClusterName         string                          `json:"cluster_name,omitempty"`          // clusters
        ContactGroups       []uint                          `json:"contact_groups,omitempty"`        // alerts
        ContentType         string                          `json:"content_type,omitempty"`          // status
        Datapoints          []ChartTextWidgetDatapoint      `json:"datapoints,omitempty"`            // charts, text
        DateWindow          string                          `json:"date_window,omitempty"`           // graphs
        Definition          ChartWidgtDefinition            `json:"definition,omitempty"`            // charts
        Dependents          string                          `json:"dependents,omitempty"`            // alerts
        DisableAutoformat   bool                            `json:"disable_autoformat,omitempty"`    // gauges
        Display             string                          `json:"display,omitempty"`               // alerts
        Format              string                          `json:"format,omitempty"`                // forecasts
        Formula             string                          `json:"formula,omitempty"`               // gauges
        GraphUUID           string                          `json:"graph_id,omitempty"`              // graphs
        HideXAxis           bool                            `json:"hide_xaxis,omitempty"`            // graphs
        HideYAxis           bool                            `json:"hide_yaxis,omitempty"`            // graphs
        HostStatusSettings  StatusWidgetHostStatusSettings  `json:"host_status_settings,omitempty"`  // status
        KeyInline           bool                            `json:"key_inline,omitempty"`            // graphs
        KeyLoc              string                          `json:"key_loc,omitempty"`               // graphs
        KeySize             uint                            `json:"key_size,omitempty"`              // graphs
        KeyWrap             bool                            `json:"key_wrap,omitempty"`              // graphs
        Label               string                          `json:"label,omitempty"`                 // graphs
        Layout              string                          `json:"layout,omitempty"`                // clusters
        Limit               uint                            `json:"limit,omitempty"`                 // lists
        Maintenance         string                          `json:"maintenance,omitempty"`           // alerts
        Markup              string                          `json:"markup,omitempty"`                // html
        MetricDisplayName   string                          `json:"metric_display_name,omitempty"`   // gauges
        MetricName          string                          `json:"metric_name,omitempty"`           // gauges
        MinAge              string                          `json:"min_age,omitempty"`               // alerts
        OffHours            []uint                          `json:"off_hours,omitempty"`             // alerts
        OverlaySetID        string                          `json:"overlay_set_id,omitempty"`        // graphs
        Period              uint                            `json:"period,omitempty"`                // gauges, text, graphs
        RangeHigh           int                             `json:"range_high,omitempty"`            // gauges
        RangeLow            int                             `json:"range_low,omitempty"`             // gauges
        Realtime            bool                            `json:"realtime,omitempty"`              // graphs
        ResourceLimit       string                          `json:"resource_limit,omitempty"`        // forecasts
        ResourceUsage       string                          `json:"resource_usage,omitempty"`        // forecasts
        Search              string                          `json:"search,omitempty"`                // alerts, lists
        Severity            string                          `json:"severity,omitempty"`              // alerts
        ShowFlags           bool                            `json:"show_flags,omitempty"`            // graphs
        Size                string                          `json:"size,omitempty"`                  // clusters
        TagFilterSet        []string                        `json:"tag_filter_set,omitempty"`        // alerts
        Threshold           float32                         `json:"threshold,omitempty"`             // clusters
        Thresholds          ForecastGaugeWidgetThresholds   `json:"thresholds,omitempty"`            // forecasts, gauges
        TimeWindow          string                          `json:"time_window,omitempty"`           // alerts
        Title               string                          `json:"title,omitempty"`                 // alerts, charts, forecasts, gauges, html
        TitleFormat         string                          `json:"title_format,omitempty"`          // text
        Trend               string                          `json:"trend,omitempty"`                 // forecasts
        Type                string                          `json:"type,omitempty"`                  // gauges, lists
        UseDefault          bool                            `json:"use_default,omitempty"`           // text
        ValueType           string                          `json:"value_type,omitempty"`            // gauges, text
        WeekDays            []string                        `json:"weekdays,omitempty"`              // alerts
}

// DashboardWidget defines widget
type DashboardWidget struct {
        Active   bool                    `json:"active"`
        Height   uint                    `json:"height"`
        Name     string                  `json:"name"`
        Origin   string                  `json:"origin"`
        Settings DashboardWidgetSettings `json:"settings"`
        Type     string                  `json:"type"`
        WidgetID string                  `json:"widget_id"`
        Width    uint                    `json:"width"`
}

// Dashboard defines a dashboard. See https://login.circonus.com/resources/api/calls/dashboard for more information.
type Dashboard struct {
        AccountDefault bool                `json:"account_default"`
        Active         bool                `json:"_active,omitempty"`
        CID            string              `json:"_cid,omitempty"`
        Created        uint                `json:"_created,omitempty"`
        CreatedBy      string              `json:"_created_by,omitempty"`
        GridLayout     DashboardGridLayout `json:"grid_layout"`
        LastModified   uint                `json:"_last_modified,omitempty"`
        Options        DashboardOptions    `json:"options"`
        Shared         bool                `json:"shared"`
        Title          string              `json:"title"`
        UUID           string              `json:"_dashboard_uuid,omitempty"`
        Widgets        []DashboardWidget   `json:"widgets"`
}

// NewDashboard returns a new Dashboard (with defaults, if applicable)
func NewDashboard() *Dashboard <span class="cov1" title="1">{
        return &amp;Dashboard{}
}</span>

// FetchDashboard retrieves dashboard with passed cid.
func (a *API) FetchDashboard(cid CIDType) (*Dashboard, error) <span class="cov7" title="4">{
        if cid == nil || *cid == "" </span><span class="cov4" title="2">{
                return nil, fmt.Errorf("Invalid dashboard CID [none]")
        }</span>

        <span class="cov4" title="2">dashboardCID := string(*cid)

        matched, err := regexp.MatchString(config.DashboardCIDRegex, dashboardCID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov4" title="2">if !matched </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("Invalid dashboard CID [%s]", dashboardCID)
        }</span>

        <span class="cov1" title="1">result, err := a.Get(string(*cid))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">if a.Debug </span><span class="cov0" title="0">{
                a.Log.Printf("[DEBUG] fetch dashboard, received JSON: %s", string(result))
        }</span>

        <span class="cov1" title="1">dashboard := new(Dashboard)
        if err := json.Unmarshal(result, dashboard); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">return dashboard, nil</span>
}

// FetchDashboards retrieves all dashboards available to the API Token.
func (a *API) FetchDashboards() (*[]Dashboard, error) <span class="cov4" title="2">{
        result, err := a.Get(config.DashboardPrefix)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov4" title="2">var dashboards []Dashboard
        if err := json.Unmarshal(result, &amp;dashboards); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov4" title="2">return &amp;dashboards, nil</span>
}

// UpdateDashboard updates passed dashboard.
func (a *API) UpdateDashboard(cfg *Dashboard) (*Dashboard, error) <span class="cov6" title="3">{
        if cfg == nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("Invalid dashboard config [nil]")
        }</span>

        <span class="cov4" title="2">dashboardCID := string(cfg.CID)

        matched, err := regexp.MatchString(config.DashboardCIDRegex, dashboardCID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov4" title="2">if !matched </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("Invalid dashboard CID [%s]", dashboardCID)
        }</span>

        <span class="cov1" title="1">jsonCfg, err := json.Marshal(cfg)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">if a.Debug </span><span class="cov0" title="0">{
                a.Log.Printf("[DEBUG] update dashboard, sending JSON: %s", string(jsonCfg))
        }</span>

        <span class="cov1" title="1">result, err := a.Put(dashboardCID, jsonCfg)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">dashboard := &amp;Dashboard{}
        if err := json.Unmarshal(result, dashboard); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">return dashboard, nil</span>
}

// CreateDashboard creates a new dashboard.
func (a *API) CreateDashboard(cfg *Dashboard) (*Dashboard, error) <span class="cov4" title="2">{
        if cfg == nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("Invalid dashboard config [nil]")
        }</span>

        <span class="cov1" title="1">jsonCfg, err := json.Marshal(cfg)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">if a.Debug </span><span class="cov0" title="0">{
                a.Log.Printf("[DEBUG] create dashboard, sending JSON: %s", string(jsonCfg))
        }</span>

        <span class="cov1" title="1">result, err := a.Post(config.DashboardPrefix, jsonCfg)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">dashboard := &amp;Dashboard{}
        if err := json.Unmarshal(result, dashboard); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">return dashboard, nil</span>
}

// DeleteDashboard deletes passed dashboard.
func (a *API) DeleteDashboard(cfg *Dashboard) (bool, error) <span class="cov6" title="3">{
        if cfg == nil </span><span class="cov1" title="1">{
                return false, fmt.Errorf("Invalid dashboard config [nil]")
        }</span>
        <span class="cov4" title="2">return a.DeleteDashboardByCID(CIDType(&amp;cfg.CID))</span>
}

// DeleteDashboardByCID deletes dashboard with passed cid.
func (a *API) DeleteDashboardByCID(cid CIDType) (bool, error) <span class="cov10" title="6">{
        if cid == nil || *cid == "" </span><span class="cov4" title="2">{
                return false, fmt.Errorf("Invalid dashboard CID [none]")
        }</span>

        <span class="cov7" title="4">dashboardCID := string(*cid)

        matched, err := regexp.MatchString(config.DashboardCIDRegex, dashboardCID)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>
        <span class="cov7" title="4">if !matched </span><span class="cov4" title="2">{
                return false, fmt.Errorf("Invalid dashboard CID [%s]", dashboardCID)
        }</span>

        <span class="cov4" title="2">_, err = a.Delete(dashboardCID)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov4" title="2">return true, nil</span>
}

// SearchDashboards returns dashboards matching the specified
// search query and/or filter. If nil is passed for both parameters
// all dashboards will be returned.
func (a *API) SearchDashboards(searchCriteria *SearchQueryType, filterCriteria *SearchFilterType) (*[]Dashboard, error) <span class="cov7" title="4">{
        q := url.Values{}

        if searchCriteria != nil &amp;&amp; *searchCriteria != "" </span><span class="cov4" title="2">{
                q.Set("search", string(*searchCriteria))
        }</span>

        <span class="cov7" title="4">if filterCriteria != nil &amp;&amp; len(*filterCriteria) &gt; 0 </span><span class="cov4" title="2">{
                for filter, criteria := range *filterCriteria </span><span class="cov4" title="2">{
                        for _, val := range criteria </span><span class="cov4" title="2">{
                                q.Add(filter, val)
                        }</span>
                }
        }

        <span class="cov7" title="4">if q.Encode() == "" </span><span class="cov1" title="1">{
                return a.FetchDashboards()
        }</span>

        <span class="cov6" title="3">reqURL := url.URL{
                Path:     config.DashboardPrefix,
                RawQuery: q.Encode(),
        }

        result, err := a.Get(reqURL.String())
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("[ERROR] API call error %+v", err)
        }</span>

        <span class="cov6" title="3">var dashboards []Dashboard
        if err := json.Unmarshal(result, &amp;dashboards); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov6" title="3">return &amp;dashboards, nil</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">// Copyright 2016 Circonus, Inc. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Graph API support - Fetch, Create, Update, Delete, and Search
// See: https://login.circonus.com/resources/api/calls/graph

package api

import (
        "encoding/json"
        "fmt"
        "net/url"
        "regexp"

        "github.com/circonus-labs/circonus-gometrics/api/config"
)

// GraphAccessKey defines an access key for a graph
type GraphAccessKey struct {
        Active         bool   `json:"active,omitempty"`           // boolean
        Height         uint   `json:"height,omitempty"`           // uint
        Key            string `json:"key,omitempty"`              // string
        Legend         bool   `json:"legend,omitempty"`           // boolean
        LockDate       bool   `json:"lock_date,omitempty"`        // boolean
        LockMode       string `json:"lock_mode,omitempty"`        // string
        LockRangeEnd   uint   `json:"lock_range_end,omitempty"`   // uint
        LockRangeStart uint   `json:"lock_range_start,omitempty"` // uint
        LockShowTimes  bool   `json:"lock_show_times,omitempty"`  // boolean
        LockZoom       string `json:"lock_zoom,omitempty"`        // string
        Nickname       string `json:"nickname,omitempty"`         // string
        Title          bool   `json:"title,omitempty"`            // boolean
        Width          uint   `json:"width,omitempty"`            // uint
        XLabels        bool   `json:"x_labels,omitempty"`         // boolean
        YLabels        bool   `json:"y_labels,omitempty"`         // boolean
}

// GraphComposite defines a composite
type GraphComposite struct {
        Axis          string  `json:"axis,omitempty"`           // string
        Color         string  `json:"color,omitempty"`          // string
        DataFormula   *string `json:"data_formula,omitempty"`   // string or null
        Hidden        bool    `json:"hidden,omitempty"`         // boolean
        LegendFormula *string `json:"legend_formula,omitempty"` // string or null
        Name          string  `json:"name,omitempty"`           // string
        Stack         *uint   `json:"stack,omitempty"`          // uint or null
}

// GraphDatapoint defines a datapoint
type GraphDatapoint struct {
        Alpha         *float64    `json:"alpha,string,omitempty"` // float64
        Axis          string      `json:"axis,omitempty"`         // string
        CAQL          *string     `json:"caql,omitempty"`         // string or null
        CheckID       uint        `json:"check_id,omitempty"`     // uint
        Color         *string     `json:"color,omitempty"`        // string
        DataFormula   *string     `json:"data_formula"`           // string or null
        Derive        interface{} `json:"derive,omitempty"`       // BUG doc: string, api: string or boolean(for caql statements)
        Hidden        bool        `json:"hidden"`                 // boolean
        LegendFormula *string     `json:"legend_formula"`         // string or null
        MetricName    string      `json:"metric_name,omitempty"`  // string
        MetricType    string      `json:"metric_type,omitempty"`  // string
        Name          string      `json:"name"`                   // string
        Stack         *uint       `json:"stack"`                  // uint or null
}

// GraphGuide defines a guide
type GraphGuide struct {
        Color         string  `json:"color,omitempty"`          // string
        DataFormula   *string `json:"data_formula,omitempty"`   // string or null
        Hidden        bool    `json:"hidden,omitempty"`         // boolean
        LegendFormula *string `json:"legend_formula,omitempty"` // string or null
        Name          string  `json:"name,omitempty"`           // string
}

// GraphMetricCluster defines a metric cluster
type GraphMetricCluster struct {
        AggregateFunc string  `json:"aggregate_function,omitempty"` // string
        Axis          string  `json:"axis,omitempty"`               // string
        Color         *string `json:"color,omitempty"`              // string
        DataFormula   *string `json:"data_formula"`                 // string or null
        Hidden        bool    `json:"hidden"`                       // boolean
        LegendFormula *string `json:"legend_formula"`               // string or null
        MetricCluster string  `json:"metric_cluster,omitempty"`     // string
        Name          string  `json:"name,omitempty"`               // string
        Stack         *uint   `json:"stack"`                        // uint or null
}

// OverlayDataOptions defines overlay options for data. Note, each overlay type requires
// a _subset_ of the options. See Graph API documentation (URL above) for details.
type OverlayDataOptions struct {
        Alerts        *int   `json:"alerts,string,omitempty"`         // int encoded as string BUG doc: numeric, api: string
        ArrayOutput   *int   `json:"array_output,string,omitempty"`   // int encoded as string BUG doc: numeric, api: string
        BasePeriod    *int   `json:"base_period,string,omitempty"`    // int encoded as string BUG doc: numeric, api: string
        Delay         *int   `json:"delay,string,omitempty"`          // int encoded as string BUG doc: numeric, api: string
        Extension     string `json:"extension,omitempty"`             // string
        GraphTitle    string `json:"graph_title,omitempty"`           // string
        GraphUUID     string `json:"graph_id,omitempty"`              // string
        InPercent     *bool  `json:"in_percent,string,omitempty"`     // boolean encoded as string BUG doc: boolean, api: string
        Inverse       *int   `json:"inverse,string,omitempty"`        // int encoded as string BUG doc: numeric, api: string
        Method        string `json:"method,omitempty"`                // string
        Model         string `json:"model,omitempty"`                 // string
        ModelEnd      string `json:"model_end,omitempty"`             // string
        ModelPeriod   string `json:"model_period,omitempty"`          // string
        ModelRelative *int   `json:"model_relative,string,omitempty"` // int encoded as string BUG doc: numeric, api: string
        Out           string `json:"out,omitempty"`                   // string
        Prequel       string `json:"prequel,omitempty"`               // string
        Presets       string `json:"presets,omitempty"`               // string
        Quantiles     string `json:"quantiles,omitempty"`             // string
        SeasonLength  *int   `json:"season_length,string,omitempty"`  // int encoded as string BUG doc: numeric, api: string
        Sensitivity   *int   `json:"sensitivity,string,omitempty"`    // int encoded as string BUG doc: numeric, api: string
        SingleValue   *int   `json:"single_value,string,omitempty"`   // int encoded as string BUG doc: numeric, api: string
        TargetPeriod  string `json:"target_period,omitempty"`         // string
        TimeOffset    string `json:"time_offset,omitempty"`           // string
        TimeShift     *int   `json:"time_shift,string,omitempty"`     // int encoded as string BUG doc: numeric, api: string
        Transform     string `json:"transform,omitempty"`             // string
        Version       *int   `json:"version,string,omitempty"`        // int encoded as string BUG doc: numeric, api: string
        Window        *int   `json:"window,string,omitempty"`         // int encoded as string BUG doc: numeric, api: string
        XShift        string `json:"x_shift,omitempty"`               // string
}

// OverlayUISpecs defines UI specs for overlay
type OverlayUISpecs struct {
        Decouple bool   `json:"decouple,omitempty"` // boolean
        ID       string `json:"id,omitempty"`       // string
        Label    string `json:"label,omitempty"`    // string
        Type     string `json:"type,omitempty"`     // string
        Z        *int   `json:"z,string,omitempty"` // int encoded as string BUG doc: numeric, api: string
}

// GraphOverlaySet defines overlays for graph
type GraphOverlaySet struct {
        DataOpts OverlayDataOptions `json:"data_opts,omitempty"` // OverlayDataOptions
        ID       string             `json:"id,omitempty"`        // string
        Title    string             `json:"title,omitempty"`     // string
        UISpecs  OverlayUISpecs     `json:"ui_specs,omitempty"`  // OverlayUISpecs
}

// Graph defines a graph. See https://login.circonus.com/resources/api/calls/graph for more information.
type Graph struct {
        AccessKeys     []GraphAccessKey            `json:"access_keys,omitempty"`                // [] len &gt;= 0
        CID            string                      `json:"_cid,omitempty"`                       // string
        Composites     []GraphComposite            `json:"composites,omitempty"`                 // [] len &gt;= 0
        Datapoints     []GraphDatapoint            `json:"datapoints,omitempt"`                  // [] len &gt;= 0
        Description    string                      `json:"description,omitempty"`                // string
        Guides         []GraphGuide                `json:"guides,omitempty"`                     // [] len &gt;= 0
        LineStyle      *string                     `json:"line_style"`                           // string or null
        LogLeftY       *int                        `json:"logarithmic_left_y,string,omitempty"`  // int encoded as string or null BUG doc: number (not string)
        LogRightY      *int                        `json:"logarithmic_right_y,string,omitempty"` // int encoded as string or null BUG doc: number (not string)
        MaxLeftY       *float64                    `json:"max_left_y,string,omitempty"`          // float64 encoded as string or null BUG doc: number (not string)
        MaxRightY      *float64                    `json:"max_right_y,string,omitempty"`         // float64 encoded as string or null BUG doc: number (not string)
        MetricClusters []GraphMetricCluster        `json:"metric_clusters,omitempty"`            // [] len &gt;= 0
        MinLeftY       *float64                    `json:"min_left_y,string,omitempty"`          // float64 encoded as string or null BUG doc: number (not string)
        MinRightY      *float64                    `json:"min_right_y,string,omitempty"`         // float64 encoded as string or null BUG doc: number (not string)
        Notes          *string                     `json:"notes,omitempty"`                      // string or null
        OverlaySets    *map[string]GraphOverlaySet `json:"overlay_sets,omitempty"`               // GroupOverLaySets or null
        Style          *string                     `json:"style"`                                // string or null
        Tags           []string                    `json:"tags,omitempty"`                       // [] len &gt;= 0
        Title          string                      `json:"title,omitempty"`                      // string
}

// NewGraph returns a Graph (with defaults, if applicable)
func NewGraph() *Graph <span class="cov1" title="1">{
        return &amp;Graph{}
}</span>

// FetchGraph retrieves graph with passed cid.
func (a *API) FetchGraph(cid CIDType) (*Graph, error) <span class="cov7" title="4">{
        if cid == nil || *cid == "" </span><span class="cov4" title="2">{
                return nil, fmt.Errorf("Invalid graph CID [none]")
        }</span>

        <span class="cov4" title="2">graphCID := string(*cid)

        matched, err := regexp.MatchString(config.GraphCIDRegex, graphCID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov4" title="2">if !matched </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("Invalid graph CID [%s]", graphCID)
        }</span>

        <span class="cov1" title="1">result, err := a.Get(graphCID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov1" title="1">if a.Debug </span><span class="cov0" title="0">{
                a.Log.Printf("[DEBUG] fetch graph, received JSON: %s", string(result))
        }</span>

        <span class="cov1" title="1">graph := new(Graph)
        if err := json.Unmarshal(result, graph); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">return graph, nil</span>
}

// FetchGraphs retrieves all graphs available to the API Token.
func (a *API) FetchGraphs() (*[]Graph, error) <span class="cov4" title="2">{
        result, err := a.Get(config.GraphPrefix)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov4" title="2">var graphs []Graph
        if err := json.Unmarshal(result, &amp;graphs); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov4" title="2">return &amp;graphs, nil</span>
}

// UpdateGraph updates passed graph.
func (a *API) UpdateGraph(cfg *Graph) (*Graph, error) <span class="cov6" title="3">{
        if cfg == nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("Invalid graph config [nil]")
        }</span>

        <span class="cov4" title="2">graphCID := string(cfg.CID)

        matched, err := regexp.MatchString(config.GraphCIDRegex, graphCID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov4" title="2">if !matched </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("Invalid graph CID [%s]", graphCID)
        }</span>

        <span class="cov1" title="1">jsonCfg, err := json.Marshal(cfg)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">if a.Debug </span><span class="cov0" title="0">{
                a.Log.Printf("[DEBUG] update graph, sending JSON: %s", string(jsonCfg))
        }</span>

        <span class="cov1" title="1">result, err := a.Put(graphCID, jsonCfg)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">graph := &amp;Graph{}
        if err := json.Unmarshal(result, graph); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">return graph, nil</span>
}

// CreateGraph creates a new graph.
func (a *API) CreateGraph(cfg *Graph) (*Graph, error) <span class="cov4" title="2">{
        if cfg == nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("Invalid graph config [nil]")
        }</span>

        <span class="cov1" title="1">jsonCfg, err := json.Marshal(cfg)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">if a.Debug </span><span class="cov0" title="0">{
                a.Log.Printf("[DEBUG] update graph, sending JSON: %s", string(jsonCfg))
        }</span>

        <span class="cov1" title="1">result, err := a.Post(config.GraphPrefix, jsonCfg)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">graph := &amp;Graph{}
        if err := json.Unmarshal(result, graph); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">return graph, nil</span>
}

// DeleteGraph deletes passed graph.
func (a *API) DeleteGraph(cfg *Graph) (bool, error) <span class="cov6" title="3">{
        if cfg == nil </span><span class="cov1" title="1">{
                return false, fmt.Errorf("Invalid graph config [nil]")
        }</span>
        <span class="cov4" title="2">return a.DeleteGraphByCID(CIDType(&amp;cfg.CID))</span>
}

// DeleteGraphByCID deletes graph with passed cid.
func (a *API) DeleteGraphByCID(cid CIDType) (bool, error) <span class="cov10" title="6">{
        if cid == nil || *cid == "" </span><span class="cov4" title="2">{
                return false, fmt.Errorf("Invalid graph CID [none]")
        }</span>

        <span class="cov7" title="4">graphCID := string(*cid)

        matched, err := regexp.MatchString(config.GraphCIDRegex, graphCID)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>
        <span class="cov7" title="4">if !matched </span><span class="cov4" title="2">{
                return false, fmt.Errorf("Invalid graph CID [%s]", graphCID)
        }</span>

        <span class="cov4" title="2">_, err = a.Delete(graphCID)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov4" title="2">return true, nil</span>
}

// SearchGraphs returns graphs matching the specified search query
// and/or filter. If nil is passed for both parameters all graphs
// will be returned.
func (a *API) SearchGraphs(searchCriteria *SearchQueryType, filterCriteria *SearchFilterType) (*[]Graph, error) <span class="cov7" title="4">{
        q := url.Values{}

        if searchCriteria != nil &amp;&amp; *searchCriteria != "" </span><span class="cov4" title="2">{
                q.Set("search", string(*searchCriteria))
        }</span>

        <span class="cov7" title="4">if filterCriteria != nil &amp;&amp; len(*filterCriteria) &gt; 0 </span><span class="cov4" title="2">{
                for filter, criteria := range *filterCriteria </span><span class="cov4" title="2">{
                        for _, val := range criteria </span><span class="cov4" title="2">{
                                q.Add(filter, val)
                        }</span>
                }
        }

        <span class="cov7" title="4">if q.Encode() == "" </span><span class="cov1" title="1">{
                return a.FetchGraphs()
        }</span>

        <span class="cov6" title="3">reqURL := url.URL{
                Path:     config.GraphPrefix,
                RawQuery: q.Encode(),
        }

        result, err := a.Get(reqURL.String())
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("[ERROR] API call error %+v", err)
        }</span>

        <span class="cov6" title="3">var graphs []Graph
        if err := json.Unmarshal(result, &amp;graphs); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov6" title="3">return &amp;graphs, nil</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">// Copyright 2016 Circonus, Inc. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Maintenance window API support - Fetch, Create, Update, Delete, and Search
// See: https://login.circonus.com/resources/api/calls/maintenance

package api

import (
        "encoding/json"
        "fmt"
        "net/url"
        "regexp"

        "github.com/circonus-labs/circonus-gometrics/api/config"
)

// Maintenance defines a maintenance window. See https://login.circonus.com/resources/api/calls/maintenance for more information.
type Maintenance struct {
        CID        string      `json:"_cid,omitempty"`       // string
        Item       string      `json:"item,omitempty"`       // string
        Notes      string      `json:"notes,omitempty"`      // string
        Severities interface{} `json:"severities,omitempty"` // []string NOTE can be set with CSV string or []string
        Start      uint        `json:"start,omitempty"`      // uint
        Stop       uint        `json:"stop,omitempty"`       // uint
        Tags       []string    `json:"tags,omitempty"`       // [] len &gt;= 0
        Type       string      `json:"type,omitempty"`       // string
}

// NewMaintenanceWindow returns a new Maintenance window (with defaults, if applicable)
func NewMaintenanceWindow() *Maintenance <span class="cov1" title="1">{
        return &amp;Maintenance{}
}</span>

// FetchMaintenanceWindow retrieves maintenance [window] with passed cid.
func (a *API) FetchMaintenanceWindow(cid CIDType) (*Maintenance, error) <span class="cov7" title="4">{
        if cid == nil || *cid == "" </span><span class="cov4" title="2">{
                return nil, fmt.Errorf("Invalid maintenance window CID [none]")
        }</span>

        <span class="cov4" title="2">maintenanceCID := string(*cid)

        matched, err := regexp.MatchString(config.MaintenanceCIDRegex, maintenanceCID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov4" title="2">if !matched </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("Invalid maintenance window CID [%s]", maintenanceCID)
        }</span>

        <span class="cov1" title="1">result, err := a.Get(maintenanceCID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">if a.Debug </span><span class="cov0" title="0">{
                a.Log.Printf("[DEBUG] fetch maintenance window, received JSON: %s", string(result))
        }</span>

        <span class="cov1" title="1">window := &amp;Maintenance{}
        if err := json.Unmarshal(result, window); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">return window, nil</span>
}

// FetchMaintenanceWindows retrieves all maintenance [windows] available to API Token.
func (a *API) FetchMaintenanceWindows() (*[]Maintenance, error) <span class="cov4" title="2">{
        result, err := a.Get(config.MaintenancePrefix)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov4" title="2">var windows []Maintenance
        if err := json.Unmarshal(result, &amp;windows); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov4" title="2">return &amp;windows, nil</span>
}

// UpdateMaintenanceWindow updates passed maintenance [window].
func (a *API) UpdateMaintenanceWindow(cfg *Maintenance) (*Maintenance, error) <span class="cov6" title="3">{
        if cfg == nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("Invalid maintenance window config [nil]")
        }</span>

        <span class="cov4" title="2">maintenanceCID := string(cfg.CID)

        matched, err := regexp.MatchString(config.MaintenanceCIDRegex, maintenanceCID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov4" title="2">if !matched </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("Invalid maintenance window CID [%s]", maintenanceCID)
        }</span>

        <span class="cov1" title="1">jsonCfg, err := json.Marshal(cfg)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">if a.Debug </span><span class="cov0" title="0">{
                a.Log.Printf("[DEBUG] update maintenance window, sending JSON: %s", string(jsonCfg))
        }</span>

        <span class="cov1" title="1">result, err := a.Put(maintenanceCID, jsonCfg)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">window := &amp;Maintenance{}
        if err := json.Unmarshal(result, window); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">return window, nil</span>
}

// CreateMaintenanceWindow creates a new maintenance [window].
func (a *API) CreateMaintenanceWindow(cfg *Maintenance) (*Maintenance, error) <span class="cov4" title="2">{
        if cfg == nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("Invalid maintenance window config [nil]")
        }</span>

        <span class="cov1" title="1">jsonCfg, err := json.Marshal(cfg)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">if a.Debug </span><span class="cov0" title="0">{
                a.Log.Printf("[DEBUG] create maintenance window, sending JSON: %s", string(jsonCfg))
        }</span>

        <span class="cov1" title="1">result, err := a.Post(config.MaintenancePrefix, jsonCfg)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">window := &amp;Maintenance{}
        if err := json.Unmarshal(result, window); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">return window, nil</span>
}

// DeleteMaintenanceWindow deletes passed maintenance [window].
func (a *API) DeleteMaintenanceWindow(cfg *Maintenance) (bool, error) <span class="cov6" title="3">{
        if cfg == nil </span><span class="cov1" title="1">{
                return false, fmt.Errorf("Invalid maintenance window config [nil]")
        }</span>
        <span class="cov4" title="2">return a.DeleteMaintenanceWindowByCID(CIDType(&amp;cfg.CID))</span>
}

// DeleteMaintenanceWindowByCID deletes maintenance [window] with passed cid.
func (a *API) DeleteMaintenanceWindowByCID(cid CIDType) (bool, error) <span class="cov10" title="6">{
        if cid == nil || *cid == "" </span><span class="cov4" title="2">{
                return false, fmt.Errorf("Invalid maintenance window CID [none]")
        }</span>

        <span class="cov7" title="4">maintenanceCID := string(*cid)

        matched, err := regexp.MatchString(config.MaintenanceCIDRegex, maintenanceCID)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>
        <span class="cov7" title="4">if !matched </span><span class="cov4" title="2">{
                return false, fmt.Errorf("Invalid maintenance window CID [%s]", maintenanceCID)
        }</span>

        <span class="cov4" title="2">_, err = a.Delete(maintenanceCID)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov4" title="2">return true, nil</span>
}

// SearchMaintenanceWindows returns maintenance [windows] matching
// the specified search query and/or filter. If nil is passed for
// both parameters all maintenance [windows] will be returned.
func (a *API) SearchMaintenanceWindows(searchCriteria *SearchQueryType, filterCriteria *SearchFilterType) (*[]Maintenance, error) <span class="cov7" title="4">{
        q := url.Values{}

        if searchCriteria != nil &amp;&amp; *searchCriteria != "" </span><span class="cov4" title="2">{
                q.Set("search", string(*searchCriteria))
        }</span>

        <span class="cov7" title="4">if filterCriteria != nil &amp;&amp; len(*filterCriteria) &gt; 0 </span><span class="cov4" title="2">{
                for filter, criteria := range *filterCriteria </span><span class="cov4" title="2">{
                        for _, val := range criteria </span><span class="cov4" title="2">{
                                q.Add(filter, val)
                        }</span>
                }
        }

        <span class="cov7" title="4">if q.Encode() == "" </span><span class="cov1" title="1">{
                return a.FetchMaintenanceWindows()
        }</span>

        <span class="cov6" title="3">reqURL := url.URL{
                Path:     config.MaintenancePrefix,
                RawQuery: q.Encode(),
        }

        result, err := a.Get(reqURL.String())
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("[ERROR] API call error %+v", err)
        }</span>

        <span class="cov6" title="3">var windows []Maintenance
        if err := json.Unmarshal(result, &amp;windows); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov6" title="3">return &amp;windows, nil</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">// Copyright 2016 Circonus, Inc. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Metric API support - Fetch, Create*, Update, Delete*, and Search
// See: https://login.circonus.com/resources/api/calls/metric
// *  : create and delete are handled via check_bundle or check_bundle_metrics

package api

import (
        "encoding/json"
        "fmt"
        "net/url"
        "regexp"

        "github.com/circonus-labs/circonus-gometrics/api/config"
)

// Metric defines a metric. See https://login.circonus.com/resources/api/calls/metric for more information.
type Metric struct {
        Active         bool     `json:"_active,omitempty"`       // boolean
        CheckActive    bool     `json:"_check_active,omitempty"` // boolean
        CheckBundleCID string   `json:"_check_bundle,omitempty"` // string
        CheckCID       string   `json:"_check,omitempty"`        // string
        CheckTags      []string `json:"_check_tags,omitempty"`   // [] len &gt;= 0
        CheckUUID      string   `json:"_check_uuid,omitempty"`   // string
        CID            string   `json:"_cid,omitempty"`          // string
        Histogram      string   `json:"_histogram,omitempty"`    // string
        Link           *string  `json:"link,omitempty"`          // string or null
        MetricName     string   `json:"_metric_name,omitempty"`  // string
        MetricType     string   `json:"_metric_type,omitempty"`  // string
        Notes          *string  `json:"notes,omitempty"`         // string or null
        Tags           []string `json:"tags,omitempty"`          // [] len &gt;= 0
        Units          *string  `json:"units,omitempty"`         // string or null
}

// FetchMetric retrieves metric with passed cid.
func (a *API) FetchMetric(cid CIDType) (*Metric, error) <span class="cov8" title="3">{
        if cid == nil || *cid == "" </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("Invalid metric CID [none]")
        }</span>

        <span class="cov5" title="2">metricCID := string(*cid)

        matched, err := regexp.MatchString(config.MetricCIDRegex, metricCID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov5" title="2">if !matched </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("Invalid metric CID [%s]", metricCID)
        }</span>

        <span class="cov1" title="1">result, err := a.Get(metricCID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">if a.Debug </span><span class="cov0" title="0">{
                a.Log.Printf("[DEBUG] fetch metric, received JSON: %s", string(result))
        }</span>

        <span class="cov1" title="1">metric := &amp;Metric{}
        if err := json.Unmarshal(result, metric); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">return metric, nil</span>
}

// FetchMetrics retrieves all metrics available to API Token.
func (a *API) FetchMetrics() (*[]Metric, error) <span class="cov5" title="2">{
        result, err := a.Get(config.MetricPrefix)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov5" title="2">var metrics []Metric
        if err := json.Unmarshal(result, &amp;metrics); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov5" title="2">return &amp;metrics, nil</span>
}

// UpdateMetric updates passed metric.
func (a *API) UpdateMetric(cfg *Metric) (*Metric, error) <span class="cov5" title="2">{
        if cfg == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("Invalid metric config [nil]")
        }</span>

        <span class="cov5" title="2">metricCID := string(cfg.CID)

        matched, err := regexp.MatchString(config.MetricCIDRegex, metricCID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov5" title="2">if !matched </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("Invalid metric CID [%s]", metricCID)
        }</span>

        <span class="cov1" title="1">jsonCfg, err := json.Marshal(cfg)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">if a.Debug </span><span class="cov0" title="0">{
                a.Log.Printf("[DEBUG] update metric, sending JSON: %s", string(jsonCfg))
        }</span>

        <span class="cov1" title="1">result, err := a.Put(metricCID, jsonCfg)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">metric := &amp;Metric{}
        if err := json.Unmarshal(result, metric); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">return metric, nil</span>
}

// SearchMetrics returns metrics matching the specified search query
// and/or filter. If nil is passed for both parameters all metrics
// will be returned.
func (a *API) SearchMetrics(searchCriteria *SearchQueryType, filterCriteria *SearchFilterType) (*[]Metric, error) <span class="cov10" title="4">{
        q := url.Values{}

        if searchCriteria != nil &amp;&amp; *searchCriteria != "" </span><span class="cov5" title="2">{
                q.Set("search", string(*searchCriteria))
        }</span>

        <span class="cov10" title="4">if filterCriteria != nil &amp;&amp; len(*filterCriteria) &gt; 0 </span><span class="cov5" title="2">{
                for filter, criteria := range *filterCriteria </span><span class="cov5" title="2">{
                        for _, val := range criteria </span><span class="cov5" title="2">{
                                q.Add(filter, val)
                        }</span>
                }
        }

        <span class="cov10" title="4">if q.Encode() == "" </span><span class="cov1" title="1">{
                return a.FetchMetrics()
        }</span>

        <span class="cov8" title="3">reqURL := url.URL{
                Path:     config.MetricPrefix,
                RawQuery: q.Encode(),
        }

        result, err := a.Get(reqURL.String())
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("[ERROR] API call error %+v", err)
        }</span>

        <span class="cov8" title="3">var metrics []Metric
        if err := json.Unmarshal(result, &amp;metrics); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="3">return &amp;metrics, nil</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">// Copyright 2016 Circonus, Inc. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Metric Cluster API support - Fetch, Create, Update, Delete, and Search
// See: https://login.circonus.com/resources/api/calls/metric_cluster

package api

import (
        "encoding/json"
        "fmt"
        "net/url"
        "regexp"

        "github.com/circonus-labs/circonus-gometrics/api/config"
)

// MetricQuery object
type MetricQuery struct {
        Query string `json:"query"`
        Type  string `json:"type"`
}

// MetricCluster defines a metric cluster. See https://login.circonus.com/resources/api/calls/metric_cluster for more information.
type MetricCluster struct {
        CID                 string              `json:"_cid,omitempty"`                   // string
        Description         string              `json:"description"`                      // string
        MatchingMetrics     []string            `json:"_matching_metrics,omitempty"`      // [] len &gt;= 1 (result info only, if query has extras - cannot be set)
        MatchingUUIDMetrics map[string][]string `json:"_matching_uuid_metrics,omitempty"` // [] len &gt;= 1 (result info only, if query has extras - cannot be set)
        Name                string              `json:"name"`                             // string
        Queries             []MetricQuery       `json:"queries"`                          // [] len &gt;= 1
        Tags                []string            `json:"tags"`                             // [] len &gt;= 0
}

// NewMetricCluster returns a new MetricCluster (with defaults, if applicable)
func NewMetricCluster() *MetricCluster <span class="cov1" title="1">{
        return &amp;MetricCluster{}
}</span>

// FetchMetricCluster retrieves metric cluster with passed cid.
func (a *API) FetchMetricCluster(cid CIDType, extras string) (*MetricCluster, error) <span class="cov10" title="6">{
        if cid == nil || *cid == "" </span><span class="cov4" title="2">{
                return nil, fmt.Errorf("Invalid metric cluster CID [none]")
        }</span>

        <span class="cov7" title="4">clusterCID := string(*cid)

        matched, err := regexp.MatchString(config.MetricClusterCIDRegex, clusterCID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov7" title="4">if !matched </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("Invalid metric cluster CID [%s]", clusterCID)
        }</span>

        <span class="cov6" title="3">reqURL := url.URL{
                Path: clusterCID,
        }

        extra := ""
        switch extras </span>{
        case "metrics":<span class="cov1" title="1">
                extra = "_matching_metrics"</span>
        case "uuids":<span class="cov1" title="1">
                extra = "_matching_uuid_metrics"</span>
        }

        <span class="cov6" title="3">if extra != "" </span><span class="cov4" title="2">{
                q := url.Values{}
                q.Set("extra", extra)
                reqURL.RawQuery = q.Encode()
        }</span>

        <span class="cov6" title="3">result, err := a.Get(reqURL.String())
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov6" title="3">if a.Debug </span><span class="cov0" title="0">{
                a.Log.Printf("[DEBUG] fetch metric cluster, received JSON: %s", string(result))
        }</span>

        <span class="cov6" title="3">cluster := &amp;MetricCluster{}
        if err := json.Unmarshal(result, cluster); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov6" title="3">return cluster, nil</span>
}

// FetchMetricClusters retrieves all metric clusters available to API Token.
func (a *API) FetchMetricClusters(extras string) (*[]MetricCluster, error) <span class="cov7" title="4">{
        reqURL := url.URL{
                Path: config.MetricClusterPrefix,
        }

        extra := ""
        switch extras </span>{
        case "metrics":<span class="cov1" title="1">
                extra = "_matching_metrics"</span>
        case "uuids":<span class="cov1" title="1">
                extra = "_matching_uuid_metrics"</span>
        }

        <span class="cov7" title="4">if extra != "" </span><span class="cov4" title="2">{
                q := url.Values{}
                q.Set("extra", extra)
                reqURL.RawQuery = q.Encode()
        }</span>

        <span class="cov7" title="4">result, err := a.Get(reqURL.String())
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov7" title="4">var clusters []MetricCluster
        if err := json.Unmarshal(result, &amp;clusters); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov7" title="4">return &amp;clusters, nil</span>
}

// UpdateMetricCluster updates passed metric cluster.
func (a *API) UpdateMetricCluster(cfg *MetricCluster) (*MetricCluster, error) <span class="cov6" title="3">{
        if cfg == nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("Invalid metric cluster config [nil]")
        }</span>

        <span class="cov4" title="2">clusterCID := string(cfg.CID)

        matched, err := regexp.MatchString(config.MetricClusterCIDRegex, clusterCID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov4" title="2">if !matched </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("Invalid metric cluster CID [%s]", clusterCID)
        }</span>

        <span class="cov1" title="1">jsonCfg, err := json.Marshal(cfg)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">if a.Debug </span><span class="cov0" title="0">{
                a.Log.Printf("[DEBUG] update metric cluster, sending JSON: %s", string(jsonCfg))
        }</span>

        <span class="cov1" title="1">result, err := a.Put(clusterCID, jsonCfg)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">cluster := &amp;MetricCluster{}
        if err := json.Unmarshal(result, cluster); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">return cluster, nil</span>
}

// CreateMetricCluster creates a new metric cluster.
func (a *API) CreateMetricCluster(cfg *MetricCluster) (*MetricCluster, error) <span class="cov4" title="2">{
        if cfg == nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("Invalid metric cluster config [nil]")
        }</span>

        <span class="cov1" title="1">jsonCfg, err := json.Marshal(cfg)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">if a.Debug </span><span class="cov0" title="0">{
                a.Log.Printf("[DEBUG] create metric cluster, sending JSON: %s", string(jsonCfg))
        }</span>

        <span class="cov1" title="1">result, err := a.Post(config.MetricClusterPrefix, jsonCfg)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">cluster := &amp;MetricCluster{}
        if err := json.Unmarshal(result, cluster); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">return cluster, nil</span>
}

// DeleteMetricCluster deletes passed metric cluster.
func (a *API) DeleteMetricCluster(cfg *MetricCluster) (bool, error) <span class="cov6" title="3">{
        if cfg == nil </span><span class="cov1" title="1">{
                return false, fmt.Errorf("Invalid metric cluster config [nil]")
        }</span>
        <span class="cov4" title="2">return a.DeleteMetricClusterByCID(CIDType(&amp;cfg.CID))</span>
}

// DeleteMetricClusterByCID deletes metric cluster with passed cid.
func (a *API) DeleteMetricClusterByCID(cid CIDType) (bool, error) <span class="cov10" title="6">{
        if cid == nil || *cid == "" </span><span class="cov4" title="2">{
                return false, fmt.Errorf("Invalid metric cluster CID [none]")
        }</span>

        <span class="cov7" title="4">clusterCID := string(*cid)

        matched, err := regexp.MatchString(config.MetricClusterCIDRegex, clusterCID)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>
        <span class="cov7" title="4">if !matched </span><span class="cov4" title="2">{
                return false, fmt.Errorf("Invalid metric cluster CID [%s]", clusterCID)
        }</span>

        <span class="cov4" title="2">_, err = a.Delete(clusterCID)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov4" title="2">return true, nil</span>
}

// SearchMetricClusters returns metric clusters matching the specified
// search query and/or filter. If nil is passed for both parameters
// all metric clusters will be returned.
func (a *API) SearchMetricClusters(searchCriteria *SearchQueryType, filterCriteria *SearchFilterType) (*[]MetricCluster, error) <span class="cov7" title="4">{
        q := url.Values{}

        if searchCriteria != nil &amp;&amp; *searchCriteria != "" </span><span class="cov4" title="2">{
                q.Set("search", string(*searchCriteria))
        }</span>

        <span class="cov7" title="4">if filterCriteria != nil &amp;&amp; len(*filterCriteria) &gt; 0 </span><span class="cov4" title="2">{
                for filter, criteria := range *filterCriteria </span><span class="cov4" title="2">{
                        for _, val := range criteria </span><span class="cov4" title="2">{
                                q.Add(filter, val)
                        }</span>
                }
        }

        <span class="cov7" title="4">if q.Encode() == "" </span><span class="cov1" title="1">{
                return a.FetchMetricClusters("")
        }</span>

        <span class="cov6" title="3">reqURL := url.URL{
                Path:     config.MetricClusterPrefix,
                RawQuery: q.Encode(),
        }

        result, err := a.Get(reqURL.String())
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("[ERROR] API call error %+v", err)
        }</span>

        <span class="cov6" title="3">var clusters []MetricCluster
        if err := json.Unmarshal(result, &amp;clusters); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov6" title="3">return &amp;clusters, nil</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">// Copyright 2016 Circonus, Inc. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// OutlierReport API support - Fetch, Create, Update, Delete, and Search
// See: https://login.circonus.com/resources/api/calls/report

package api

import (
        "encoding/json"
        "fmt"
        "net/url"
        "regexp"

        "github.com/circonus-labs/circonus-gometrics/api/config"
)

// OutlierReport defines a outlier report. See https://login.circonus.com/resources/api/calls/report for more information.
type OutlierReport struct {
        CID              string   `json:"_cid,omitempty"`              // string
        Config           string   `json:"config,omitempty"`            // string
        Created          uint     `json:"_created,omitempty"`          // uint
        CreatedBy        string   `json:"_created_by,omitempty"`       // string
        LastModified     uint     `json:"_last_modified,omitempty"`    // uint
        LastModifiedBy   string   `json:"_last_modified_by,omitempty"` // string
        MetricClusterCID string   `json:"metric_cluster,omitempty"`    // st ring
        Tags             []string `json:"tags,omitempty"`              // [] len &gt;= 0
        Title            string   `json:"title,omitempty"`             // string
}

// NewOutlierReport returns a new OutlierReport (with defaults, if applicable)
func NewOutlierReport() *OutlierReport <span class="cov1" title="1">{
        return &amp;OutlierReport{}
}</span>

// FetchOutlierReport retrieves outlier report with passed cid.
func (a *API) FetchOutlierReport(cid CIDType) (*OutlierReport, error) <span class="cov7" title="4">{
        if cid == nil || *cid == "" </span><span class="cov4" title="2">{
                return nil, fmt.Errorf("Invalid outlier report CID [none]")
        }</span>

        <span class="cov4" title="2">reportCID := string(*cid)

        matched, err := regexp.MatchString(config.OutlierReportCIDRegex, reportCID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov4" title="2">if !matched </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("Invalid outlier report CID [%s]", reportCID)
        }</span>

        <span class="cov1" title="1">result, err := a.Get(reportCID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">if a.Debug </span><span class="cov0" title="0">{
                a.Log.Printf("[DEBUG] fetch outlier report, received JSON: %s", string(result))
        }</span>

        <span class="cov1" title="1">report := &amp;OutlierReport{}
        if err := json.Unmarshal(result, report); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">return report, nil</span>
}

// FetchOutlierReports retrieves all outlier reports available to API Token.
func (a *API) FetchOutlierReports() (*[]OutlierReport, error) <span class="cov4" title="2">{
        result, err := a.Get(config.OutlierReportPrefix)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov4" title="2">var reports []OutlierReport
        if err := json.Unmarshal(result, &amp;reports); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov4" title="2">return &amp;reports, nil</span>
}

// UpdateOutlierReport updates passed outlier report.
func (a *API) UpdateOutlierReport(cfg *OutlierReport) (*OutlierReport, error) <span class="cov6" title="3">{
        if cfg == nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("Invalid outlier report config [nil]")
        }</span>

        <span class="cov4" title="2">reportCID := string(cfg.CID)

        matched, err := regexp.MatchString(config.OutlierReportCIDRegex, reportCID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov4" title="2">if !matched </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("Invalid outlier report CID [%s]", reportCID)
        }</span>

        <span class="cov1" title="1">jsonCfg, err := json.Marshal(cfg)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">if a.Debug </span><span class="cov0" title="0">{
                a.Log.Printf("[DEBUG] update outlier report, sending JSON: %s", string(jsonCfg))
        }</span>

        <span class="cov1" title="1">result, err := a.Put(reportCID, jsonCfg)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">report := &amp;OutlierReport{}
        if err := json.Unmarshal(result, report); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">return report, nil</span>
}

// CreateOutlierReport creates a new outlier report.
func (a *API) CreateOutlierReport(cfg *OutlierReport) (*OutlierReport, error) <span class="cov4" title="2">{
        if cfg == nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("Invalid outlier report config [nil]")
        }</span>

        <span class="cov1" title="1">jsonCfg, err := json.Marshal(cfg)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">if a.Debug </span><span class="cov0" title="0">{
                a.Log.Printf("[DEBUG] create outlier report, sending JSON: %s", string(jsonCfg))
        }</span>

        <span class="cov1" title="1">result, err := a.Post(config.OutlierReportPrefix, jsonCfg)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">report := &amp;OutlierReport{}
        if err := json.Unmarshal(result, report); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">return report, nil</span>
}

// DeleteOutlierReport deletes passed outlier report.
func (a *API) DeleteOutlierReport(cfg *OutlierReport) (bool, error) <span class="cov6" title="3">{
        if cfg == nil </span><span class="cov1" title="1">{
                return false, fmt.Errorf("Invalid outlier report config [nil]")
        }</span>
        <span class="cov4" title="2">return a.DeleteOutlierReportByCID(CIDType(&amp;cfg.CID))</span>
}

// DeleteOutlierReportByCID deletes outlier report with passed cid.
func (a *API) DeleteOutlierReportByCID(cid CIDType) (bool, error) <span class="cov10" title="6">{
        if cid == nil || *cid == "" </span><span class="cov4" title="2">{
                return false, fmt.Errorf("Invalid outlier report CID [none]")
        }</span>

        <span class="cov7" title="4">reportCID := string(*cid)

        matched, err := regexp.MatchString(config.OutlierReportCIDRegex, reportCID)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>
        <span class="cov7" title="4">if !matched </span><span class="cov4" title="2">{
                return false, fmt.Errorf("Invalid outlier report CID [%s]", reportCID)
        }</span>

        <span class="cov4" title="2">_, err = a.Delete(reportCID)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov4" title="2">return true, nil</span>
}

// SearchOutlierReports returns outlier report matching the
// specified search query and/or filter. If nil is passed for
// both parameters all outlier report will be returned.
func (a *API) SearchOutlierReports(searchCriteria *SearchQueryType, filterCriteria *SearchFilterType) (*[]OutlierReport, error) <span class="cov7" title="4">{
        q := url.Values{}

        if searchCriteria != nil &amp;&amp; *searchCriteria != "" </span><span class="cov4" title="2">{
                q.Set("search", string(*searchCriteria))
        }</span>

        <span class="cov7" title="4">if filterCriteria != nil &amp;&amp; len(*filterCriteria) &gt; 0 </span><span class="cov4" title="2">{
                for filter, criteria := range *filterCriteria </span><span class="cov4" title="2">{
                        for _, val := range criteria </span><span class="cov4" title="2">{
                                q.Add(filter, val)
                        }</span>
                }
        }

        <span class="cov7" title="4">if q.Encode() == "" </span><span class="cov1" title="1">{
                return a.FetchOutlierReports()
        }</span>

        <span class="cov6" title="3">reqURL := url.URL{
                Path:     config.OutlierReportPrefix,
                RawQuery: q.Encode(),
        }

        result, err := a.Get(reqURL.String())
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("[ERROR] API call error %+v", err)
        }</span>

        <span class="cov6" title="3">var reports []OutlierReport
        if err := json.Unmarshal(result, &amp;reports); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov6" title="3">return &amp;reports, nil</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">// Copyright 2016 Circonus, Inc. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// ProvisionBroker API support - Fetch, Create, and Update
// See: https://login.circonus.com/resources/api/calls/provision_broker
// Note that the provision_broker endpoint does not return standard cid format
//      of '/object/item' (e.g. /provision_broker/abc-123) it just returns 'item'

package api

import (
        "encoding/json"
        "fmt"
        "regexp"

        "github.com/circonus-labs/circonus-gometrics/api/config"
)

// BrokerStratcon defines stratcons for broker
type BrokerStratcon struct {
        CN   string `json:"cn,omitempty"`   // string
        Host string `json:"host,omitempty"` // string
        Port string `json:"port,omitempty"` // string
}

// ProvisionBroker defines a provision broker [request]. See https://login.circonus.com/resources/api/calls/provision_broker for more details.
type ProvisionBroker struct {
        Cert                    string           `json:"_cert,omitempty"`                     // string
        CID                     string           `json:"_cid,omitempty"`                      // string
        CSR                     string           `json:"_csr,omitempty"`                      // string
        ExternalHost            string           `json:"external_host,omitempty"`             // string
        ExternalPort            string           `json:"external_port,omitempty"`             // string
        IPAddress               string           `json:"ipaddress,omitempty"`                 // string
        Latitude                string           `json:"latitude,omitempty"`                  // string
        Longitude               string           `json:"longitude,omitempty"`                 // string
        Name                    string           `json:"noit_name,omitempty"`                 // string
        Port                    string           `json:"port,omitempty"`                      // string
        PreferReverseConnection bool             `json:"prefer_reverse_connection,omitempty"` // boolean
        Rebuild                 bool             `json:"rebuild,omitempty"`                   // boolean
        Stratcons               []BrokerStratcon `json:"_stratcons,omitempty"`                // [] len &gt;= 1
        Tags                    []string         `json:"tags,omitempty"`                      // [] len &gt;= 0
}

// NewProvisionBroker returns a new ProvisionBroker (with defaults, if applicable)
func NewProvisionBroker() *ProvisionBroker <span class="cov1" title="1">{
        return &amp;ProvisionBroker{}
}</span>

// FetchProvisionBroker retrieves provision broker [request] with passed cid.
func (a *API) FetchProvisionBroker(cid CIDType) (*ProvisionBroker, error) <span class="cov10" title="4">{
        if cid == nil || *cid == "" </span><span class="cov5" title="2">{
                return nil, fmt.Errorf("Invalid provision broker request CID [none]")
        }</span>

        <span class="cov5" title="2">brokerCID := string(*cid)

        matched, err := regexp.MatchString(config.ProvisionBrokerCIDRegex, brokerCID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov5" title="2">if !matched </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("Invalid provision broker request CID [%s]", brokerCID)
        }</span>

        <span class="cov1" title="1">result, err := a.Get(brokerCID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">if a.Debug </span><span class="cov0" title="0">{
                a.Log.Printf("[DEBUG] fetch broker provision request, received JSON: %s", string(result))
        }</span>

        <span class="cov1" title="1">broker := &amp;ProvisionBroker{}
        if err := json.Unmarshal(result, broker); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">return broker, nil</span>
}

// UpdateProvisionBroker updates a broker definition [request].
func (a *API) UpdateProvisionBroker(cid CIDType, cfg *ProvisionBroker) (*ProvisionBroker, error) <span class="cov10" title="4">{
        if cfg == nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("Invalid provision broker request config [nil]")
        }</span>

        <span class="cov8" title="3">if cid == nil || *cid == "" </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("Invalid provision broker request CID [none]")
        }</span>

        <span class="cov5" title="2">brokerCID := string(*cid)

        matched, err := regexp.MatchString(config.ProvisionBrokerCIDRegex, brokerCID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov5" title="2">if !matched </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("Invalid provision broker request CID [%s]", brokerCID)
        }</span>

        <span class="cov1" title="1">jsonCfg, err := json.Marshal(cfg)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">if a.Debug </span><span class="cov0" title="0">{
                a.Log.Printf("[DEBUG] update broker provision request, sending JSON: %s", string(jsonCfg))
        }</span>

        <span class="cov1" title="1">result, err := a.Put(brokerCID, jsonCfg)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">broker := &amp;ProvisionBroker{}
        if err := json.Unmarshal(result, broker); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">return broker, nil</span>
}

// CreateProvisionBroker creates a new provison broker [request].
func (a *API) CreateProvisionBroker(cfg *ProvisionBroker) (*ProvisionBroker, error) <span class="cov5" title="2">{
        if cfg == nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("Invalid provision broker request config [nil]")
        }</span>

        <span class="cov1" title="1">jsonCfg, err := json.Marshal(cfg)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">if a.Debug </span><span class="cov0" title="0">{
                a.Log.Printf("[DEBUG] create broker provision request, sending JSON: %s", string(jsonCfg))
        }</span>

        <span class="cov1" title="1">result, err := a.Post(config.ProvisionBrokerPrefix, jsonCfg)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">broker := &amp;ProvisionBroker{}
        if err := json.Unmarshal(result, broker); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">return broker, nil</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">// Copyright 2016 Circonus, Inc. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Rule Set API support - Fetch, Create, Update, Delete, and Search
// See: https://login.circonus.com/resources/api/calls/rule_set

package api

import (
        "encoding/json"
        "fmt"
        "net/url"
        "regexp"

        "github.com/circonus-labs/circonus-gometrics/api/config"
)

// RuleSetRule defines a ruleset rule
type RuleSetRule struct {
        Criteria          string      `json:"criteria"`                     // string
        Severity          uint        `json:"severity"`                     // uint
        Value             interface{} `json:"value"`                        // BUG doc: string, api: actual type returned switches based on Criteria
        Wait              uint        `json:"wait"`                         // uint
        WindowingDuration uint        `json:"windowing_duration,omitempty"` // uint
        WindowingFunction *string     `json:"windowing_function,omitempty"` // string or null
}

// RuleSet defines a ruleset. See https://login.circonus.com/resources/api/calls/rule_set for more information.
type RuleSet struct {
        CheckCID      string             `json:"check"`            // string
        CID           string             `json:"_cid,omitempty"`   // string
        ContactGroups map[uint8][]string `json:"contact_groups"`   // [] len 5
        Derive        *string            `json:"derive,omitempty"` // string or null
        Link          *string            `json:"link"`             // string or null
        MetricName    string             `json:"metric_name"`      // string
        MetricTags    []string           `json:"metric_tags"`      // [] len &gt;= 0
        MetricType    string             `json:"metric_type"`      // string
        Notes         *string            `json:"notes"`            // string or null
        Parent        *string            `json:"parent,omitempty"` // string or null
        Rules         []RuleSetRule      `json:"rules"`            // [] len &gt;= 1
        Tags          []string           `json:"tags"`             // [] len &gt;= 0
}

// NewRuleSet returns a new RuleSet (with defaults if applicable)
func NewRuleSet() *RuleSet <span class="cov1" title="1">{
        return &amp;RuleSet{}
}</span>

// FetchRuleSet retrieves rule set with passed cid.
func (a *API) FetchRuleSet(cid CIDType) (*RuleSet, error) <span class="cov7" title="4">{
        if cid == nil || *cid == "" </span><span class="cov4" title="2">{
                return nil, fmt.Errorf("Invalid rule set CID [none]")
        }</span>

        <span class="cov4" title="2">rulesetCID := string(*cid)

        matched, err := regexp.MatchString(config.RuleSetCIDRegex, rulesetCID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov4" title="2">if !matched </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("Invalid rule set CID [%s]", rulesetCID)
        }</span>

        <span class="cov1" title="1">result, err := a.Get(rulesetCID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">if a.Debug </span><span class="cov0" title="0">{
                a.Log.Printf("[DEBUG] fetch rule set, received JSON: %s", string(result))
        }</span>

        <span class="cov1" title="1">ruleset := &amp;RuleSet{}
        if err := json.Unmarshal(result, ruleset); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">return ruleset, nil</span>
}

// FetchRuleSets retrieves all rule sets available to API Token.
func (a *API) FetchRuleSets() (*[]RuleSet, error) <span class="cov4" title="2">{
        result, err := a.Get(config.RuleSetPrefix)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov4" title="2">var rulesets []RuleSet
        if err := json.Unmarshal(result, &amp;rulesets); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov4" title="2">return &amp;rulesets, nil</span>
}

// UpdateRuleSet updates passed rule set.
func (a *API) UpdateRuleSet(cfg *RuleSet) (*RuleSet, error) <span class="cov6" title="3">{
        if cfg == nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("Invalid rule set config [nil]")
        }</span>

        <span class="cov4" title="2">rulesetCID := string(cfg.CID)

        matched, err := regexp.MatchString(config.RuleSetCIDRegex, rulesetCID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov4" title="2">if !matched </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("Invalid rule set CID [%s]", rulesetCID)
        }</span>

        <span class="cov1" title="1">jsonCfg, err := json.Marshal(cfg)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">if a.Debug </span><span class="cov0" title="0">{
                a.Log.Printf("[DEBUG] update rule set, sending JSON: %s", string(jsonCfg))
        }</span>

        <span class="cov1" title="1">result, err := a.Put(rulesetCID, jsonCfg)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">ruleset := &amp;RuleSet{}
        if err := json.Unmarshal(result, ruleset); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">return ruleset, nil</span>
}

// CreateRuleSet creates a new rule set.
func (a *API) CreateRuleSet(cfg *RuleSet) (*RuleSet, error) <span class="cov4" title="2">{
        if cfg == nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("Invalid rule set config [nil]")
        }</span>

        <span class="cov1" title="1">jsonCfg, err := json.Marshal(cfg)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">if a.Debug </span><span class="cov0" title="0">{
                a.Log.Printf("[DEBUG] create rule set, sending JSON: %s", string(jsonCfg))
        }</span>

        <span class="cov1" title="1">resp, err := a.Post(config.RuleSetPrefix, jsonCfg)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">ruleset := &amp;RuleSet{}
        if err := json.Unmarshal(resp, ruleset); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">return ruleset, nil</span>
}

// DeleteRuleSet deletes passed rule set.
func (a *API) DeleteRuleSet(cfg *RuleSet) (bool, error) <span class="cov6" title="3">{
        if cfg == nil </span><span class="cov1" title="1">{
                return false, fmt.Errorf("Invalid rule set config [nil]")
        }</span>
        <span class="cov4" title="2">return a.DeleteRuleSetByCID(CIDType(&amp;cfg.CID))</span>
}

// DeleteRuleSetByCID deletes rule set with passed cid.
func (a *API) DeleteRuleSetByCID(cid CIDType) (bool, error) <span class="cov10" title="6">{
        if cid == nil || *cid == "" </span><span class="cov4" title="2">{
                return false, fmt.Errorf("Invalid rule set CID [none]")
        }</span>

        <span class="cov7" title="4">rulesetCID := string(*cid)

        matched, err := regexp.MatchString(config.RuleSetCIDRegex, rulesetCID)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>
        <span class="cov7" title="4">if !matched </span><span class="cov4" title="2">{
                return false, fmt.Errorf("Invalid rule set CID [%s]", rulesetCID)
        }</span>

        <span class="cov4" title="2">_, err = a.Delete(rulesetCID)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov4" title="2">return true, nil</span>
}

// SearchRuleSets returns rule sets matching the specified search
// query and/or filter. If nil is passed for both parameters all
// rule sets will be returned.
func (a *API) SearchRuleSets(searchCriteria *SearchQueryType, filterCriteria *SearchFilterType) (*[]RuleSet, error) <span class="cov7" title="4">{
        q := url.Values{}

        if searchCriteria != nil &amp;&amp; *searchCriteria != "" </span><span class="cov4" title="2">{
                q.Set("search", string(*searchCriteria))
        }</span>

        <span class="cov7" title="4">if filterCriteria != nil &amp;&amp; len(*filterCriteria) &gt; 0 </span><span class="cov4" title="2">{
                for filter, criteria := range *filterCriteria </span><span class="cov4" title="2">{
                        for _, val := range criteria </span><span class="cov4" title="2">{
                                q.Add(filter, val)
                        }</span>
                }
        }

        <span class="cov7" title="4">if q.Encode() == "" </span><span class="cov1" title="1">{
                return a.FetchRuleSets()
        }</span>

        <span class="cov6" title="3">reqURL := url.URL{
                Path:     config.RuleSetPrefix,
                RawQuery: q.Encode(),
        }

        result, err := a.Get(reqURL.String())
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("[ERROR] API call error %+v", err)
        }</span>

        <span class="cov6" title="3">var rulesets []RuleSet
        if err := json.Unmarshal(result, &amp;rulesets); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov6" title="3">return &amp;rulesets, nil</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">// Copyright 2016 Circonus, Inc. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// RuleSetGroup API support - Fetch, Create, Update, Delete, and Search
// See: https://login.circonus.com/resources/api/calls/rule_set_group

package api

import (
        "encoding/json"
        "fmt"
        "net/url"
        "regexp"

        "github.com/circonus-labs/circonus-gometrics/api/config"
)

// RuleSetGroupFormula defines a formula for raising alerts
type RuleSetGroupFormula struct {
        Expression    interface{} `json:"expression"`     // string or uint BUG doc: string, api: string or numeric
        RaiseSeverity uint        `json:"raise_severity"` // uint
        Wait          uint        `json:"wait"`           // uint
}

// RuleSetGroupCondition defines conditions for raising alerts
type RuleSetGroupCondition struct {
        MatchingSeverities []string `json:"matching_serverities"` // [] len &gt;= 1
        RuleSetCID         string   `json:"rule_set"`             // string
}

// RuleSetGroup defines a ruleset group. See https://login.circonus.com/resources/api/calls/rule_set_group for more information.
type RuleSetGroup struct {
        CID               string                  `json:"_cid,omitempty"`      // string
        ContactGroups     map[uint8][]string      `json:"contact_groups"`      // [] len == 5
        Formulas          []RuleSetGroupFormula   `json:"formulas"`            // [] len &gt;= 0
        Name              string                  `json:"name"`                // string
        RuleSetConditions []RuleSetGroupCondition `json:"rule_set_conditions"` // [] len &gt;= 1
        Tags              []string                `json:"tags"`                // [] len &gt;= 0
}

// NewRuleSetGroup returns a new RuleSetGroup (with defaults, if applicable)
func NewRuleSetGroup() *RuleSetGroup <span class="cov1" title="1">{
        return &amp;RuleSetGroup{}
}</span>

// FetchRuleSetGroup retrieves rule set group with passed cid.
func (a *API) FetchRuleSetGroup(cid CIDType) (*RuleSetGroup, error) <span class="cov7" title="4">{
        if cid == nil || *cid == "" </span><span class="cov4" title="2">{
                return nil, fmt.Errorf("Invalid rule set group CID [none]")
        }</span>

        <span class="cov4" title="2">groupCID := string(*cid)

        matched, err := regexp.MatchString(config.RuleSetGroupCIDRegex, groupCID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov4" title="2">if !matched </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("Invalid rule set group CID [%s]", groupCID)
        }</span>

        <span class="cov1" title="1">result, err := a.Get(groupCID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">if a.Debug </span><span class="cov0" title="0">{
                a.Log.Printf("[DEBUG] fetch rule set group, received JSON: %s", string(result))
        }</span>

        <span class="cov1" title="1">rulesetGroup := &amp;RuleSetGroup{}
        if err := json.Unmarshal(result, rulesetGroup); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">return rulesetGroup, nil</span>
}

// FetchRuleSetGroups retrieves all rule set groups available to API Token.
func (a *API) FetchRuleSetGroups() (*[]RuleSetGroup, error) <span class="cov4" title="2">{
        result, err := a.Get(config.RuleSetGroupPrefix)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov4" title="2">var rulesetGroups []RuleSetGroup
        if err := json.Unmarshal(result, &amp;rulesetGroups); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov4" title="2">return &amp;rulesetGroups, nil</span>
}

// UpdateRuleSetGroup updates passed rule set group.
func (a *API) UpdateRuleSetGroup(cfg *RuleSetGroup) (*RuleSetGroup, error) <span class="cov6" title="3">{
        if cfg == nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("Invalid rule set group config [nil]")
        }</span>

        <span class="cov4" title="2">groupCID := string(cfg.CID)

        matched, err := regexp.MatchString(config.RuleSetGroupCIDRegex, groupCID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov4" title="2">if !matched </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("Invalid rule set group CID [%s]", groupCID)
        }</span>

        <span class="cov1" title="1">jsonCfg, err := json.Marshal(cfg)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">if a.Debug </span><span class="cov0" title="0">{
                a.Log.Printf("[DEBUG] update rule set group, sending JSON: %s", string(jsonCfg))
        }</span>

        <span class="cov1" title="1">result, err := a.Put(groupCID, jsonCfg)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">groups := &amp;RuleSetGroup{}
        if err := json.Unmarshal(result, groups); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">return groups, nil</span>
}

// CreateRuleSetGroup creates a new rule set group.
func (a *API) CreateRuleSetGroup(cfg *RuleSetGroup) (*RuleSetGroup, error) <span class="cov4" title="2">{
        if cfg == nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("Invalid rule set group config [nil]")
        }</span>

        <span class="cov1" title="1">jsonCfg, err := json.Marshal(cfg)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">if a.Debug </span><span class="cov0" title="0">{
                a.Log.Printf("[DEBUG] create rule set group, sending JSON: %s", string(jsonCfg))
        }</span>

        <span class="cov1" title="1">result, err := a.Post(config.RuleSetGroupPrefix, jsonCfg)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">group := &amp;RuleSetGroup{}
        if err := json.Unmarshal(result, group); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">return group, nil</span>
}

// DeleteRuleSetGroup deletes passed rule set group.
func (a *API) DeleteRuleSetGroup(cfg *RuleSetGroup) (bool, error) <span class="cov6" title="3">{
        if cfg == nil </span><span class="cov1" title="1">{
                return false, fmt.Errorf("Invalid rule set group config [nil]")
        }</span>
        <span class="cov4" title="2">return a.DeleteRuleSetGroupByCID(CIDType(&amp;cfg.CID))</span>
}

// DeleteRuleSetGroupByCID deletes rule set group wiht passed cid.
func (a *API) DeleteRuleSetGroupByCID(cid CIDType) (bool, error) <span class="cov10" title="6">{
        if cid == nil || *cid == "" </span><span class="cov4" title="2">{
                return false, fmt.Errorf("Invalid rule set group CID [none]")
        }</span>

        <span class="cov7" title="4">groupCID := string(*cid)

        matched, err := regexp.MatchString(config.RuleSetGroupCIDRegex, groupCID)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>
        <span class="cov7" title="4">if !matched </span><span class="cov4" title="2">{
                return false, fmt.Errorf("Invalid rule set group CID [%s]", groupCID)
        }</span>

        <span class="cov4" title="2">_, err = a.Delete(groupCID)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov4" title="2">return true, nil</span>
}

// SearchRuleSetGroups returns rule set groups matching the
// specified search query and/or filter. If nil is passed for
// both parameters all rule set groups will be returned.
func (a *API) SearchRuleSetGroups(searchCriteria *SearchQueryType, filterCriteria *SearchFilterType) (*[]RuleSetGroup, error) <span class="cov7" title="4">{
        q := url.Values{}

        if searchCriteria != nil &amp;&amp; *searchCriteria != "" </span><span class="cov4" title="2">{
                q.Set("search", string(*searchCriteria))
        }</span>

        <span class="cov7" title="4">if filterCriteria != nil &amp;&amp; len(*filterCriteria) &gt; 0 </span><span class="cov4" title="2">{
                for filter, criteria := range *filterCriteria </span><span class="cov4" title="2">{
                        for _, val := range criteria </span><span class="cov4" title="2">{
                                q.Add(filter, val)
                        }</span>
                }
        }

        <span class="cov7" title="4">if q.Encode() == "" </span><span class="cov1" title="1">{
                return a.FetchRuleSetGroups()
        }</span>

        <span class="cov6" title="3">reqURL := url.URL{
                Path:     config.RuleSetGroupPrefix,
                RawQuery: q.Encode(),
        }

        result, err := a.Get(reqURL.String())
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("[ERROR] API call error %+v", err)
        }</span>

        <span class="cov6" title="3">var groups []RuleSetGroup
        if err := json.Unmarshal(result, &amp;groups); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov6" title="3">return &amp;groups, nil</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">// Copyright 2016 Circonus, Inc. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// User API support - Fetch, Update, and Search
// See: https://login.circonus.com/resources/api/calls/user
// Note: Create and Delete are not supported directly via the User API
// endpoint. See the Account endpoint for inviting and removing users
// from specific accounts.

package api

import (
        "encoding/json"
        "fmt"
        "net/url"
        "regexp"

        "github.com/circonus-labs/circonus-gometrics/api/config"
)

// UserContactInfo defines known contact details
type UserContactInfo struct {
        SMS  string `json:"sms,omitempty"`  // string
        XMPP string `json:"xmpp,omitempty"` // string
}

// User defines a user. See https://login.circonus.com/resources/api/calls/user for more information.
type User struct {
        CID         string          `json:"_cid,omitempty"`         // string
        ContactInfo UserContactInfo `json:"contact_info,omitempty"` // UserContactInfo
        Email       string          `json:"email"`                  // string
        Firstname   string          `json:"firstname"`              // string
        Lastname    string          `json:"lastname"`               // string
}

// FetchUser retrieves user with passed cid. Pass nil for '/user/current'.
func (a *API) FetchUser(cid CIDType) (*User, error) <span class="cov10" title="4">{
        var userCID string

        if cid == nil || *cid == "" </span><span class="cov5" title="2">{
                userCID = config.UserPrefix + "/current"
        }</span><span class="cov5" title="2"> else {
                userCID = string(*cid)
        }</span>

        <span class="cov10" title="4">matched, err := regexp.MatchString(config.UserCIDRegex, userCID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov10" title="4">if !matched </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("Invalid user CID [%s]", userCID)
        }</span>

        <span class="cov8" title="3">result, err := a.Get(userCID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="3">if a.Debug </span><span class="cov0" title="0">{
                a.Log.Printf("[DEBUG] fetch user, received JSON: %s", string(result))
        }</span>

        <span class="cov8" title="3">user := new(User)
        if err := json.Unmarshal(result, user); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="3">return user, nil</span>
}

// FetchUsers retrieves all users available to API Token.
func (a *API) FetchUsers() (*[]User, error) <span class="cov5" title="2">{
        result, err := a.Get(config.UserPrefix)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov5" title="2">var users []User
        if err := json.Unmarshal(result, &amp;users); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov5" title="2">return &amp;users, nil</span>
}

// UpdateUser updates passed user.
func (a *API) UpdateUser(cfg *User) (*User, error) <span class="cov8" title="3">{
        if cfg == nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("Invalid user config [nil]")
        }</span>

        <span class="cov5" title="2">userCID := string(cfg.CID)

        matched, err := regexp.MatchString(config.UserCIDRegex, userCID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov5" title="2">if !matched </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("Invalid user CID [%s]", userCID)
        }</span>

        <span class="cov1" title="1">jsonCfg, err := json.Marshal(cfg)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">if a.Debug </span><span class="cov0" title="0">{
                a.Log.Printf("[DEBUG] update user, sending JSON: %s", string(jsonCfg))
        }</span>

        <span class="cov1" title="1">result, err := a.Put(userCID, jsonCfg)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">user := &amp;User{}
        if err := json.Unmarshal(result, user); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">return user, nil</span>
}

// SearchUsers returns users matching a filter (search queries
// are not suppoted by the user endpoint). Pass nil as filter for all
// users available to the API Token.
func (a *API) SearchUsers(filterCriteria *SearchFilterType) (*[]User, error) <span class="cov5" title="2">{
        q := url.Values{}

        if filterCriteria != nil &amp;&amp; len(*filterCriteria) &gt; 0 </span><span class="cov1" title="1">{
                for filter, criteria := range *filterCriteria </span><span class="cov5" title="2">{
                        for _, val := range criteria </span><span class="cov5" title="2">{
                                q.Add(filter, val)
                        }</span>
                }
        }

        <span class="cov5" title="2">if q.Encode() == "" </span><span class="cov1" title="1">{
                return a.FetchUsers()
        }</span>

        <span class="cov1" title="1">reqURL := url.URL{
                Path:     config.UserPrefix,
                RawQuery: q.Encode(),
        }

        result, err := a.Get(reqURL.String())
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("[ERROR] API call error %+v", err)
        }</span>

        <span class="cov1" title="1">var users []User
        if err := json.Unmarshal(result, &amp;users); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">return &amp;users, nil</span>
}
</pre>
		
		<pre class="file" id="file20" style="display: none">// Copyright 2016 Circonus, Inc. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Worksheet API support - Fetch, Create, Update, Delete, and Search
// See: https://login.circonus.com/resources/api/calls/worksheet

package api

import (
        "encoding/json"
        "fmt"
        "net/url"
        "regexp"

        "github.com/circonus-labs/circonus-gometrics/api/config"
)

// WorksheetGraph defines a worksheet cid to be include in the worksheet
type WorksheetGraph struct {
        GraphCID string `json:"graph"` // string
}

// WorksheetSmartQuery defines a query to include multiple worksheets
type WorksheetSmartQuery struct {
        Name  string   `json:"name"`
        Order []string `json:"order"`
        Query string   `json:"query"`
}

// Worksheet defines a worksheet. See https://login.circonus.com/resources/api/calls/worksheet for more information.
type Worksheet struct {
        CID          string                `json:"_cid,omitempty"`          // string
        Description  *string               `json:"description"`             // string or null
        Favorite     bool                  `json:"favorite"`                // boolean
        Graphs       []WorksheetGraph      `json:"worksheets,omitempty"`    // [] len &gt;= 0
        Notes        *string               `json:"notes"`                   // string or null
        SmartQueries []WorksheetSmartQuery `json:"smart_queries,omitempty"` // [] len &gt;= 0
        Tags         []string              `json:"tags"`                    // [] len &gt;= 0
        Title        string                `json:"title"`                   // string
}

// NewWorksheet returns a new Worksheet (with defaults, if applicable)
func NewWorksheet() *Worksheet <span class="cov1" title="1">{
        return &amp;Worksheet{}
}</span>

// FetchWorksheet retrieves worksheet with passed cid.
func (a *API) FetchWorksheet(cid CIDType) (*Worksheet, error) <span class="cov7" title="4">{
        if cid == nil || *cid == "" </span><span class="cov4" title="2">{
                return nil, fmt.Errorf("Invalid worksheet CID [none]")
        }</span>

        <span class="cov4" title="2">worksheetCID := string(*cid)

        matched, err := regexp.MatchString(config.WorksheetCIDRegex, worksheetCID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov4" title="2">if !matched </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("Invalid worksheet CID [%s]", worksheetCID)
        }</span>

        <span class="cov1" title="1">result, err := a.Get(string(*cid))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">if a.Debug </span><span class="cov0" title="0">{
                a.Log.Printf("[DEBUG] fetch worksheet, received JSON: %s", string(result))
        }</span>

        <span class="cov1" title="1">worksheet := new(Worksheet)
        if err := json.Unmarshal(result, worksheet); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">return worksheet, nil</span>
}

// FetchWorksheets retrieves all worksheets available to API Token.
func (a *API) FetchWorksheets() (*[]Worksheet, error) <span class="cov4" title="2">{
        result, err := a.Get(config.WorksheetPrefix)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov4" title="2">var worksheets []Worksheet
        if err := json.Unmarshal(result, &amp;worksheets); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov4" title="2">return &amp;worksheets, nil</span>
}

// UpdateWorksheet updates passed worksheet.
func (a *API) UpdateWorksheet(cfg *Worksheet) (*Worksheet, error) <span class="cov6" title="3">{
        if cfg == nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("Invalid worksheet config [nil]")
        }</span>

        <span class="cov4" title="2">worksheetCID := string(cfg.CID)

        matched, err := regexp.MatchString(config.WorksheetCIDRegex, worksheetCID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov4" title="2">if !matched </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("Invalid worksheet CID [%s]", worksheetCID)
        }</span>

        <span class="cov1" title="1">jsonCfg, err := json.Marshal(cfg)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">if a.Debug </span><span class="cov0" title="0">{
                a.Log.Printf("[DEBUG] update worksheet, sending JSON: %s", string(jsonCfg))
        }</span>

        <span class="cov1" title="1">result, err := a.Put(worksheetCID, jsonCfg)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">worksheet := &amp;Worksheet{}
        if err := json.Unmarshal(result, worksheet); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">return worksheet, nil</span>
}

// CreateWorksheet creates a new worksheet.
func (a *API) CreateWorksheet(cfg *Worksheet) (*Worksheet, error) <span class="cov4" title="2">{
        if cfg == nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("Invalid worksheet config [nil]")
        }</span>

        <span class="cov1" title="1">jsonCfg, err := json.Marshal(cfg)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">if a.Debug </span><span class="cov0" title="0">{
                a.Log.Printf("[DEBUG] create annotation, sending JSON: %s", string(jsonCfg))
        }</span>

        <span class="cov1" title="1">result, err := a.Post(config.WorksheetPrefix, jsonCfg)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">worksheet := &amp;Worksheet{}
        if err := json.Unmarshal(result, worksheet); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">return worksheet, nil</span>
}

// DeleteWorksheet deletes passed worksheet.
func (a *API) DeleteWorksheet(cfg *Worksheet) (bool, error) <span class="cov6" title="3">{
        if cfg == nil </span><span class="cov1" title="1">{
                return false, fmt.Errorf("Invalid worksheet config [nil]")
        }</span>
        <span class="cov4" title="2">return a.DeleteWorksheetByCID(CIDType(&amp;cfg.CID))</span>
}

// DeleteWorksheetByCID deletes worksheet with passed cid.
func (a *API) DeleteWorksheetByCID(cid CIDType) (bool, error) <span class="cov10" title="6">{
        if cid == nil || *cid == "" </span><span class="cov4" title="2">{
                return false, fmt.Errorf("Invalid worksheet CID [none]")
        }</span>

        <span class="cov7" title="4">worksheetCID := string(*cid)

        matched, err := regexp.MatchString(config.WorksheetCIDRegex, worksheetCID)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>
        <span class="cov7" title="4">if !matched </span><span class="cov4" title="2">{
                return false, fmt.Errorf("Invalid worksheet CID [%s]", worksheetCID)
        }</span>

        <span class="cov4" title="2">_, err = a.Delete(worksheetCID)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov4" title="2">return true, nil</span>
}

// SearchWorksheets returns worksheets matching the specified search
// query and/or filter. If nil is passed for both parameters all
// worksheets will be returned.
func (a *API) SearchWorksheets(searchCriteria *SearchQueryType, filterCriteria *SearchFilterType) (*[]Worksheet, error) <span class="cov7" title="4">{
        q := url.Values{}

        if searchCriteria != nil &amp;&amp; *searchCriteria != "" </span><span class="cov4" title="2">{
                q.Set("search", string(*searchCriteria))
        }</span>

        <span class="cov7" title="4">if filterCriteria != nil &amp;&amp; len(*filterCriteria) &gt; 0 </span><span class="cov4" title="2">{
                for filter, criteria := range *filterCriteria </span><span class="cov4" title="2">{
                        for _, val := range criteria </span><span class="cov4" title="2">{
                                q.Add(filter, val)
                        }</span>
                }
        }

        <span class="cov7" title="4">if q.Encode() == "" </span><span class="cov1" title="1">{
                return a.FetchWorksheets()
        }</span>

        <span class="cov6" title="3">reqURL := url.URL{
                Path:     config.WorksheetPrefix,
                RawQuery: q.Encode(),
        }

        result, err := a.Get(reqURL.String())
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("[ERROR] API call error %+v", err)
        }</span>

        <span class="cov6" title="3">var worksheets []Worksheet
        if err := json.Unmarshal(result, &amp;worksheets); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov6" title="3">return &amp;worksheets, nil</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">// Copyright 2016 Circonus, Inc. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package checkmgr

import (
        "fmt"
        "math/rand"
        "net"
        "net/url"
        "reflect"
        "strconv"
        "strings"
        "time"

        "github.com/circonus-labs/circonus-gometrics/api"
)

func init() <span class="cov1" title="1">{
        rand.Seed(time.Now().UnixNano())
}</span>

// Get Broker to use when creating a check
func (cm *CheckManager) getBroker() (*api.Broker, error) <span class="cov6" title="4">{
        if cm.brokerID != 0 </span><span class="cov3" title="2">{
                cid := fmt.Sprintf("/broker/%d", cm.brokerID)
                broker, err := cm.apih.FetchBroker(api.CIDType(&amp;cid))
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov3" title="2">if !cm.isValidBroker(broker) </span><span class="cov1" title="1">{
                        return nil, fmt.Errorf(
                                "[ERROR] designated broker %d [%s] is invalid (not active, does not support required check type, or connectivity issue)",
                                cm.brokerID,
                                broker.Name)
                }</span>
                <span class="cov1" title="1">return broker, nil</span>
        }
        <span class="cov3" title="2">broker, err := cm.selectBroker()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("[ERROR] Unable to fetch suitable broker %s", err)
        }</span>
        <span class="cov3" title="2">return broker, nil</span>
}

// Get CN of Broker associated with submission_url to satisfy no IP SANS in certs
func (cm *CheckManager) getBrokerCN(broker *api.Broker, submissionURL api.URLType) (string, error) <span class="cov10" title="10">{
        u, err := url.Parse(string(submissionURL))
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov10" title="10">hostParts := strings.Split(u.Host, ":")
        host := hostParts[0]

        if net.ParseIP(host) == nil </span><span class="cov1" title="1">{ // it's a non-ip string
                return u.Host, nil
        }</span>

        <span class="cov9" title="9">cn := ""

        for _, detail := range broker.Details </span><span class="cov9" title="9">{
                if *detail.IP == host </span><span class="cov9" title="8">{
                        cn = detail.CN
                        break</span>
                }
        }

        <span class="cov9" title="9">if cn == "" </span><span class="cov1" title="1">{
                return "", fmt.Errorf("[ERROR] Unable to match URL host (%s) to Broker", u.Host)
        }</span>

        <span class="cov9" title="8">return cn, nil</span>

}

// Select a broker for use when creating a check, if a specific broker
// was not specified.
func (cm *CheckManager) selectBroker() (*api.Broker, error) <span class="cov7" title="5">{
        var brokerList *[]api.Broker
        var err error

        if len(cm.brokerSelectTag) &gt; 0 </span><span class="cov3" title="2">{
                filter := api.SearchFilterType{
                        "f__tags_has": cm.brokerSelectTag,
                }
                brokerList, err = cm.apih.SearchBrokers(nil, &amp;filter)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }<span class="cov5" title="3"> else {
                brokerList, err = cm.apih.FetchBrokers()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        <span class="cov7" title="5">if len(*brokerList) == 0 </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("zero brokers found")
        }</span>

        <span class="cov6" title="4">validBrokers := make(map[string]api.Broker)
        haveEnterprise := false

        for _, broker := range *brokerList </span><span class="cov8" title="6">{
                broker := broker
                if cm.isValidBroker(&amp;broker) </span><span class="cov6" title="4">{
                        validBrokers[broker.CID] = broker
                        if broker.Type == "enterprise" </span><span class="cov5" title="3">{
                                haveEnterprise = true
                        }</span>
                }
        }

        <span class="cov6" title="4">if haveEnterprise </span><span class="cov5" title="3">{ // eliminate non-enterprise brokers from valid brokers
                for k, v := range validBrokers </span><span class="cov6" title="4">{
                        if v.Type != "enterprise" </span><span class="cov1" title="1">{
                                delete(validBrokers, k)
                        }</span>
                }
        }

        <span class="cov6" title="4">if len(validBrokers) == 0 </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("found %d broker(s), zero are valid", len(*brokerList))
        }</span>

        <span class="cov5" title="3">validBrokerKeys := reflect.ValueOf(validBrokers).MapKeys()
        selectedBroker := validBrokers[validBrokerKeys[rand.Intn(len(validBrokerKeys))].String()]

        if cm.Debug </span><span class="cov0" title="0">{
                cm.Log.Printf("[DEBUG] Selected broker '%s'\n", selectedBroker.Name)
        }</span>

        <span class="cov5" title="3">return &amp;selectedBroker, nil</span>

}

// Verify broker supports the check type to be used
func (cm *CheckManager) brokerSupportsCheckType(checkType CheckTypeType, details *api.BrokerDetail) bool <span class="cov9" title="8">{

        baseType := string(checkType)

        for _, module := range details.Modules </span><span class="cov9" title="8">{
                if module == baseType </span><span class="cov8" title="6">{
                        return true
                }</span>
        }

        <span class="cov3" title="2">if idx := strings.Index(baseType, ":"); idx &gt; 0 </span><span class="cov0" title="0">{
                baseType = baseType[0:idx]
        }</span>

        <span class="cov3" title="2">for _, module := range details.Modules </span><span class="cov3" title="2">{
                if module == baseType </span><span class="cov0" title="0">{
                        return true
                }</span>
        }

        <span class="cov3" title="2">return false</span>

}

// Is the broker valid (active, supports check type, and reachable)
func (cm *CheckManager) isValidBroker(broker *api.Broker) bool <span class="cov10" title="10">{
        var brokerHost string
        var brokerPort string
        valid := false
        for _, detail := range broker.Details </span><span class="cov10" title="10">{
                detail := detail

                // broker must be active
                if detail.Status != statusActive </span><span class="cov6" title="4">{
                        if cm.Debug </span><span class="cov0" title="0">{
                                cm.Log.Printf("[DEBUG] Broker '%s' is not active.\n", broker.Name)
                        }</span>
                        <span class="cov6" title="4">continue</span>
                }

                // broker must have module loaded for the check type to be used
                <span class="cov8" title="6">if !cm.brokerSupportsCheckType(cm.checkType, &amp;detail) </span><span class="cov1" title="1">{
                        if cm.Debug </span><span class="cov0" title="0">{
                                cm.Log.Printf("[DEBUG] Broker '%s' does not support '%s' checks.\n", broker.Name, cm.checkType)
                        }</span>
                        <span class="cov1" title="1">continue</span>
                }

                <span class="cov7" title="5">if detail.ExternalPort != 0 </span><span class="cov7" title="5">{
                        brokerPort = strconv.Itoa(int(detail.ExternalPort))
                }</span><span class="cov0" title="0"> else {
                        if *detail.Port != 0 </span><span class="cov0" title="0">{
                                brokerPort = strconv.Itoa(int(*detail.Port))
                        }</span><span class="cov0" title="0"> else {
                                brokerPort = "43191"
                        }</span>
                }

                <span class="cov7" title="5">if detail.ExternalHost != nil &amp;&amp; *detail.ExternalHost != "" </span><span class="cov7" title="5">{
                        brokerHost = *detail.ExternalHost
                }</span><span class="cov0" title="0"> else {
                        brokerHost = *detail.IP
                }</span>

                <span class="cov7" title="5">if brokerHost == "trap.noit.circonus.net" &amp;&amp; brokerPort != "443" </span><span class="cov0" title="0">{
                        brokerPort = "443"
                }</span>

                <span class="cov7" title="5">retries := 5
                for attempt := 1; attempt &lt;= retries; attempt++ </span><span class="cov7" title="5">{
                        // broker must be reachable and respond within designated time
                        conn, err := net.DialTimeout("tcp", fmt.Sprintf("%s:%s", brokerHost, brokerPort), cm.brokerMaxResponseTime)
                        if err == nil </span><span class="cov7" title="5">{
                                conn.Close()
                                valid = true
                                break</span>
                        }

                        <span class="cov0" title="0">cm.Log.Printf("[WARN] Broker '%s' unable to connect, %v. Retrying in 2 seconds, attempt %d of %d.", broker.Name, err, attempt, retries)
                        time.Sleep(2 * time.Second)</span>
                }

                <span class="cov7" title="5">if valid </span><span class="cov7" title="5">{
                        if cm.Debug </span><span class="cov0" title="0">{
                                cm.Log.Printf("[DEBUG] Broker '%s' is valid\n", broker.Name)
                        }</span>
                        <span class="cov7" title="5">break</span>
                }
        }
        <span class="cov10" title="10">return valid</span>
}
</pre>
		
		<pre class="file" id="file22" style="display: none">// Copyright 2016 Circonus, Inc. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package checkmgr

import (
        "crypto/x509"
        "encoding/json"
        "errors"
        "fmt"
)

// Default Circonus CA certificate
var circonusCA = []byte(`-----BEGIN CERTIFICATE-----
MIID4zCCA0ygAwIBAgIJAMelf8skwVWPMA0GCSqGSIb3DQEBBQUAMIGoMQswCQYD
VQQGEwJVUzERMA8GA1UECBMITWFyeWxhbmQxETAPBgNVBAcTCENvbHVtYmlhMRcw
FQYDVQQKEw5DaXJjb251cywgSW5jLjERMA8GA1UECxMIQ2lyY29udXMxJzAlBgNV
BAMTHkNpcmNvbnVzIENlcnRpZmljYXRlIEF1dGhvcml0eTEeMBwGCSqGSIb3DQEJ
ARYPY2FAY2lyY29udXMubmV0MB4XDTA5MTIyMzE5MTcwNloXDTE5MTIyMTE5MTcw
NlowgagxCzAJBgNVBAYTAlVTMREwDwYDVQQIEwhNYXJ5bGFuZDERMA8GA1UEBxMI
Q29sdW1iaWExFzAVBgNVBAoTDkNpcmNvbnVzLCBJbmMuMREwDwYDVQQLEwhDaXJj
b251czEnMCUGA1UEAxMeQ2lyY29udXMgQ2VydGlmaWNhdGUgQXV0aG9yaXR5MR4w
HAYJKoZIhvcNAQkBFg9jYUBjaXJjb251cy5uZXQwgZ8wDQYJKoZIhvcNAQEBBQAD
gY0AMIGJAoGBAKz2X0/0vJJ4ad1roehFyxUXHdkjJA9msEKwT2ojummdUB3kK5z6
PDzDL9/c65eFYWqrQWVWZSLQK1D+v9xJThCe93v6QkSJa7GZkCq9dxClXVtBmZH3
hNIZZKVC6JMA9dpRjBmlFgNuIdN7q5aJsv8VZHH+QrAyr9aQmhDJAmk1AgMBAAGj
ggERMIIBDTAdBgNVHQ4EFgQUyNTsgZHSkhhDJ5i+6IFlPzKYxsUwgd0GA1UdIwSB
1TCB0oAUyNTsgZHSkhhDJ5i+6IFlPzKYxsWhga6kgaswgagxCzAJBgNVBAYTAlVT
MREwDwYDVQQIEwhNYXJ5bGFuZDERMA8GA1UEBxMIQ29sdW1iaWExFzAVBgNVBAoT
DkNpcmNvbnVzLCBJbmMuMREwDwYDVQQLEwhDaXJjb251czEnMCUGA1UEAxMeQ2ly
Y29udXMgQ2VydGlmaWNhdGUgQXV0aG9yaXR5MR4wHAYJKoZIhvcNAQkBFg9jYUBj
aXJjb251cy5uZXSCCQDHpX/LJMFVjzAMBgNVHRMEBTADAQH/MA0GCSqGSIb3DQEB
BQUAA4GBAAHBtl15BwbSyq0dMEBpEdQYhHianU/rvOMe57digBmox7ZkPEbB/baE
sYJysziA2raOtRxVRtcxuZSMij2RiJDsLxzIp1H60Xhr8lmf7qF6Y+sZl7V36KZb
n2ezaOoRtsQl9dhqEMe8zgL76p9YZ5E69Al0mgiifTteyNjjMuIW
-----END CERTIFICATE-----`)

// CACert contains cert returned from Circonus API
type CACert struct {
        Contents string `json:"contents"`
}

// loadCACert loads the CA cert for the broker designated by the submission url
func (cm *CheckManager) loadCACert() error <span class="cov10" title="10">{
        if cm.certPool != nil </span><span class="cov7" title="5">{
                return nil
        }</span>

        <span class="cov7" title="5">cm.certPool = x509.NewCertPool()

        var cert []byte
        var err error

        if cm.enabled </span><span class="cov5" title="3">{
                // only attempt to retrieve broker CA cert if
                // the check is being managed.
                cert, err = cm.fetchCert()
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov7" title="5">if cert == nil </span><span class="cov3" title="2">{
                cert = circonusCA
        }</span>

        <span class="cov7" title="5">cm.certPool.AppendCertsFromPEM(cert)

        return nil</span>
}

// fetchCert fetches CA certificate using Circonus API
func (cm *CheckManager) fetchCert() ([]byte, error) <span class="cov6" title="4">{
        if !cm.enabled </span><span class="cov0" title="0">{
                return nil, errors.New("check manager is not enabled")
        }</span>

        <span class="cov6" title="4">response, err := cm.apih.Get("/pki/ca.crt")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov6" title="4">cadata := new(CACert)
        if err := json.Unmarshal(response, cadata); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov6" title="4">if cadata.Contents == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("[ERROR] Unable to find ca cert %+v", cadata)
        }</span>

        <span class="cov6" title="4">return []byte(cadata.Contents), nil</span>
}
</pre>
		
		<pre class="file" id="file23" style="display: none">// Copyright 2016 Circonus, Inc. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package checkmgr

import (
        "crypto/rand"
        "crypto/sha256"
        "encoding/hex"
        "errors"
        "fmt"
        "net/url"
        "strconv"
        "strings"
        "time"

        "github.com/circonus-labs/circonus-gometrics/api"
        "github.com/circonus-labs/circonus-gometrics/api/config"
)

// UpdateCheck determines if the check needs to be updated (new metrics, tags, etc.)
func (cm *CheckManager) UpdateCheck(newMetrics map[string]*api.CheckBundleMetric) <span class="cov7" title="5">{
        // only if check manager is enabled
        if !cm.enabled </span><span class="cov1" title="1">{
                return
        }</span>

        // only if checkBundle has been populated
        <span class="cov6" title="4">if cm.checkBundle == nil </span><span class="cov1" title="1">{
                return
        }</span>

        // only if there is *something* to update
        <span class="cov5" title="3">if !cm.forceCheckUpdate &amp;&amp; len(newMetrics) == 0 &amp;&amp; len(cm.metricTags) == 0 </span><span class="cov1" title="1">{
                return
        }</span>

        // refresh check bundle (in case there were changes made by other apps or in UI)
        <span class="cov3" title="2">cid := cm.checkBundle.CID
        checkBundle, err := cm.apih.FetchCheckBundle(api.CIDType(&amp;cid))
        if err != nil </span><span class="cov0" title="0">{
                cm.Log.Printf("[ERROR] unable to fetch up-to-date check bundle %v", err)
                return
        }</span>
        <span class="cov3" title="2">cm.cbmu.Lock()
        cm.checkBundle = checkBundle
        cm.cbmu.Unlock()

        // check metric_limit and see if it’s 0, if so, don't even bother to try to update the check.

        cm.addNewMetrics(newMetrics)

        if len(cm.metricTags) &gt; 0 </span><span class="cov1" title="1">{
                // note: if a tag has been added (queued) for a metric which never gets sent
                //       the tags will be discarded. (setting tags does not *create* metrics.)
                for metricName, metricTags := range cm.metricTags </span><span class="cov1" title="1">{
                        for metricIdx, metric := range cm.checkBundle.Metrics </span><span class="cov1" title="1">{
                                if metric.Name == metricName </span><span class="cov1" title="1">{
                                        cm.checkBundle.Metrics[metricIdx].Tags = metricTags
                                        break</span>
                                }
                        }
                        <span class="cov1" title="1">cm.mtmu.Lock()
                        delete(cm.metricTags, metricName)
                        cm.mtmu.Unlock()</span>
                }
                <span class="cov1" title="1">cm.forceCheckUpdate = true</span>
        }

        <span class="cov3" title="2">if cm.forceCheckUpdate </span><span class="cov3" title="2">{
                newCheckBundle, err := cm.apih.UpdateCheckBundle(cm.checkBundle)
                if err != nil </span><span class="cov0" title="0">{
                        cm.Log.Printf("[ERROR] updating check bundle %v", err)
                        return
                }</span>

                <span class="cov3" title="2">cm.forceCheckUpdate = false
                cm.cbmu.Lock()
                cm.checkBundle = newCheckBundle
                cm.cbmu.Unlock()
                cm.inventoryMetrics()</span>
        }

}

// Initialize CirconusMetrics instance. Attempt to find a check otherwise create one.
// use cases:
//
// check [bundle] by submission url
// check [bundle] by *check* id (note, not check_bundle id)
// check [bundle] by search
// create check [bundle]
func (cm *CheckManager) initializeTrapURL() error <span class="cov10" title="11">{
        if cm.trapURL != "" </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov10" title="11">cm.trapmu.Lock()
        defer cm.trapmu.Unlock()

        // special case short-circuit: just send to a url, no check management
        // up to user to ensure that if url is https that it will work (e.g. not self-signed)
        if cm.checkSubmissionURL != "" </span><span class="cov6" title="4">{
                if !cm.enabled </span><span class="cov5" title="3">{
                        cm.trapURL = cm.checkSubmissionURL
                        cm.trapLastUpdate = time.Now()
                        return nil
                }</span>
        }

        <span class="cov8" title="8">if !cm.enabled </span><span class="cov1" title="1">{
                return errors.New("unable to initialize trap, check manager is disabled")
        }</span>

        <span class="cov8" title="7">var err error
        var check *api.Check
        var checkBundle *api.CheckBundle
        var broker *api.Broker

        if cm.checkSubmissionURL != "" </span><span class="cov1" title="1">{
                check, err = cm.fetchCheckBySubmissionURL(cm.checkSubmissionURL)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov1" title="1">if !check.Active </span><span class="cov0" title="0">{
                        return fmt.Errorf("[ERROR] Check ID %v is not active", check.CID)
                }</span>
                // extract check id from check object returned from looking up using submission url
                // set m.CheckId to the id
                // set m.SubmissionUrl to "" to prevent trying to search on it going forward
                // use case: if the broker is changed in the UI metrics would stop flowing
                // unless the new submission url can be fetched with the API (which is no
                // longer possible using the original submission url)
                <span class="cov1" title="1">var id int
                id, err = strconv.Atoi(strings.Replace(check.CID, "/check/", "", -1))
                if err == nil </span><span class="cov1" title="1">{
                        cm.checkID = api.IDType(id)
                        cm.checkSubmissionURL = ""
                }</span><span class="cov0" title="0"> else {
                        cm.Log.Printf(
                                "[WARN] SubmissionUrl check to Check ID: unable to convert %s to int %q\n",
                                check.CID, err)
                }</span>
        }<span class="cov7" title="6"> else if cm.checkID &gt; 0 </span><span class="cov3" title="2">{
                cid := fmt.Sprintf("/check/%d", cm.checkID)
                check, err = cm.apih.FetchCheck(api.CIDType(&amp;cid))
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov3" title="2">if !check.Active </span><span class="cov0" title="0">{
                        return fmt.Errorf("[ERROR] Check ID %v is not active", check.CID)
                }</span>
        }<span class="cov6" title="4"> else {
                if checkBundle == nil </span><span class="cov6" title="4">{
                        // old search (instanceid as check.target)
                        searchCriteria := fmt.Sprintf(
                                "(active:1)(type:\"%s\")(host:\"%s\")(tags:%s)", cm.checkType, cm.checkTarget, strings.Join(cm.checkSearchTag, ","))
                        checkBundle, err = cm.checkBundleSearch(searchCriteria, map[string][]string{})
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }

                <span class="cov6" title="4">if checkBundle == nil </span><span class="cov3" title="2">{
                        // new search (check.target != instanceid, instanceid encoded in notes field)
                        searchCriteria := fmt.Sprintf(
                                "(active:1)(type:\"%s\")(tags:%s)", cm.checkType, strings.Join(cm.checkSearchTag, ","))
                        filterCriteria := map[string][]string{"f_notes": []string{*cm.getNotes()}}
                        checkBundle, err = cm.checkBundleSearch(searchCriteria, filterCriteria)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }

                <span class="cov6" title="4">if checkBundle == nil </span><span class="cov1" title="1">{
                        // err==nil &amp;&amp; checkBundle==nil is "no check bundles matched"
                        // an error *should* be returned for any other invalid scenario
                        checkBundle, broker, err = cm.createNewCheck()
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        }

        <span class="cov8" title="7">if checkBundle == nil </span><span class="cov5" title="3">{
                if check != nil </span><span class="cov5" title="3">{
                        cid := check.CheckBundleCID
                        checkBundle, err = cm.apih.FetchCheckBundle(api.CIDType(&amp;cid))
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }<span class="cov0" title="0"> else {
                        return fmt.Errorf("[ERROR] Unable to retrieve, find, or create check")
                }</span>
        }

        <span class="cov8" title="7">if broker == nil </span><span class="cov7" title="6">{
                cid := checkBundle.Brokers[0]
                broker, err = cm.apih.FetchBroker(api.CIDType(&amp;cid))
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        // retain to facilitate metric management (adding new metrics specifically)
        <span class="cov8" title="7">cm.checkBundle = checkBundle
        cm.inventoryMetrics()

        // determine the trap url to which metrics should be PUT
        if checkBundle.Type == "httptrap" </span><span class="cov7" title="6">{
                if turl, found := checkBundle.Config[config.SubmissionURL]; found </span><span class="cov7" title="6">{
                        cm.trapURL = api.URLType(turl)
                }</span><span class="cov0" title="0"> else {
                        if cm.Debug </span><span class="cov0" title="0">{
                                cm.Log.Printf("Missing config.%s %+v", config.SubmissionURL, checkBundle)
                        }</span>
                        <span class="cov0" title="0">return fmt.Errorf("[ERROR] Unable to use check, no %s in config", config.SubmissionURL)</span>
                }
        }<span class="cov1" title="1"> else {
                // build a submission_url for non-httptrap checks out of mtev_reverse url
                if len(checkBundle.ReverseConnectURLs) == 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("%s is not an HTTPTRAP check and no reverse connection urls found", checkBundle.Checks[0])
                }</span>
                <span class="cov1" title="1">mtevURL := checkBundle.ReverseConnectURLs[0]
                mtevURL = strings.Replace(mtevURL, "mtev_reverse", "https", 1)
                mtevURL = strings.Replace(mtevURL, "check", "module/httptrap", 1)
                if rs, found := checkBundle.Config[config.ReverseSecretKey]; found </span><span class="cov1" title="1">{
                        cm.trapURL = api.URLType(fmt.Sprintf("%s/%s", mtevURL, rs))
                }</span><span class="cov0" title="0"> else {
                        if cm.Debug </span><span class="cov0" title="0">{
                                cm.Log.Printf("Missing config.%s %+v", config.ReverseSecretKey, checkBundle)
                        }</span>
                        <span class="cov0" title="0">return fmt.Errorf("[ERROR] Unable to use check, no %s in config", config.ReverseSecretKey)</span>
                }
        }

        // used when sending as "ServerName" get around certs not having IP SANS
        // (cert created with server name as CN but IP used in trap url)
        <span class="cov8" title="7">cn, err := cm.getBrokerCN(broker, cm.trapURL)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="7">cm.trapCN = BrokerCNType(cn)

        if cm.enabled </span><span class="cov8" title="7">{
                u, err := url.Parse(string(cm.trapURL))
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="7">if u.Scheme == "https" </span><span class="cov8" title="7">{
                        if err := cm.loadCACert(); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        }

        <span class="cov8" title="7">cm.trapLastUpdate = time.Now()

        return nil</span>
}

// Search for a check bundle given a predetermined set of criteria
func (cm *CheckManager) checkBundleSearch(criteria string, filter map[string][]string) (*api.CheckBundle, error) <span class="cov7" title="6">{
        search := api.SearchQueryType(criteria)
        checkBundles, err := cm.apih.SearchCheckBundles(&amp;search, &amp;filter)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov7" title="6">if len(*checkBundles) == 0 </span><span class="cov5" title="3">{
                return nil, nil // trigger creation of a new check
        }</span>

        <span class="cov5" title="3">numActive := 0
        checkID := -1

        for idx, check := range *checkBundles </span><span class="cov5" title="3">{
                if check.Status == statusActive </span><span class="cov5" title="3">{
                        numActive++
                        checkID = idx
                }</span>
        }

        <span class="cov5" title="3">if numActive &gt; 1 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("[ERROR] multiple check bundles match criteria %s", criteria)
        }</span>

        <span class="cov5" title="3">bundle := (*checkBundles)[checkID]

        return &amp;bundle, nil</span>
}

// Create a new check to receive metrics
func (cm *CheckManager) createNewCheck() (*api.CheckBundle, *api.Broker, error) <span class="cov3" title="2">{
        checkSecret := string(cm.checkSecret)
        if checkSecret == "" </span><span class="cov3" title="2">{
                secret, err := cm.makeSecret()
                if err != nil </span><span class="cov0" title="0">{
                        secret = "myS3cr3t"
                }</span>
                <span class="cov3" title="2">checkSecret = secret</span>
        }

        <span class="cov3" title="2">broker, err := cm.getBroker()
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        <span class="cov3" title="2">chkcfg := &amp;api.CheckBundle{
                Brokers:     []string{broker.CID},
                Config:      make(map[config.Key]string),
                DisplayName: string(cm.checkDisplayName),
                Metrics:     []api.CheckBundleMetric{},
                MetricLimit: config.DefaultCheckBundleMetricLimit,
                Notes:       cm.getNotes(),
                Period:      60,
                Status:      statusActive,
                Tags:        append(cm.checkSearchTag, cm.checkTags...),
                Target:      string(cm.checkTarget),
                Timeout:     10,
                Type:        string(cm.checkType),
        }

        if len(cm.customConfigFields) &gt; 0 </span><span class="cov0" title="0">{
                for fld, val := range cm.customConfigFields </span><span class="cov0" title="0">{
                        chkcfg.Config[config.Key(fld)] = val
                }</span>
        }

        //
        // use the default config settings if these are NOT set by user configuration
        //
        <span class="cov3" title="2">if val, ok := chkcfg.Config[config.AsyncMetrics]; !ok || val == "" </span><span class="cov3" title="2">{
                chkcfg.Config[config.AsyncMetrics] = "true"
        }</span>

        <span class="cov3" title="2">if val, ok := chkcfg.Config[config.Secret]; !ok || val == "" </span><span class="cov3" title="2">{
                chkcfg.Config[config.Secret] = checkSecret
        }</span>

        <span class="cov3" title="2">checkBundle, err := cm.apih.CreateCheckBundle(chkcfg)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        <span class="cov3" title="2">return checkBundle, broker, nil</span>
}

// Create a dynamic secret to use with a new check
func (cm *CheckManager) makeSecret() (string, error) <span class="cov5" title="3">{
        hash := sha256.New()
        x := make([]byte, 2048)
        if _, err := rand.Read(x); err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov5" title="3">hash.Write(x)
        return hex.EncodeToString(hash.Sum(nil))[0:16], nil</span>
}

func (cm *CheckManager) getNotes() *string <span class="cov6" title="4">{
        notes := fmt.Sprintf("cgm_instanceid|%s", cm.checkInstanceID)
        return &amp;notes
}</span>

// FetchCheckBySubmissionURL fetch a check configuration by submission_url
func (cm *CheckManager) fetchCheckBySubmissionURL(submissionURL api.URLType) (*api.Check, error) <span class="cov1" title="1">{
        if string(submissionURL) == "" </span><span class="cov0" title="0">{
                return nil, errors.New("[ERROR] Invalid submission URL (blank)")
        }</span>

        <span class="cov1" title="1">u, err := url.Parse(string(submissionURL))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // valid trap url: scheme://host[:port]/module/httptrap/UUID/secret

        // does it smell like a valid trap url path
        <span class="cov1" title="1">if !strings.Contains(u.Path, "/module/httptrap/") </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("[ERROR] Invalid submission URL '%s', unrecognized path", submissionURL)
        }</span>

        // extract uuid
        <span class="cov1" title="1">pathParts := strings.Split(strings.Replace(u.Path, "/module/httptrap/", "", 1), "/")
        if len(pathParts) != 2 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("[ERROR] Invalid submission URL '%s', UUID not where expected", submissionURL)
        }</span>
        <span class="cov1" title="1">uuid := pathParts[0]

        filter := api.SearchFilterType{"f__check_uuid": []string{uuid}}

        checks, err := cm.apih.SearchChecks(nil, &amp;filter)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">if len(*checks) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("[ERROR] No checks found with UUID %s", uuid)
        }</span>

        <span class="cov1" title="1">numActive := 0
        checkID := -1

        for idx, check := range *checks </span><span class="cov1" title="1">{
                if check.Active </span><span class="cov1" title="1">{
                        numActive++
                        checkID = idx
                }</span>
        }

        <span class="cov1" title="1">if numActive &gt; 1 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("[ERROR] Multiple checks with same UUID %s", uuid)
        }</span>

        <span class="cov1" title="1">check := (*checks)[checkID]

        return &amp;check, nil</span>

}
</pre>
		
		<pre class="file" id="file24" style="display: none">// Copyright 2016 Circonus, Inc. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Package checkmgr provides a check management interace to circonus-gometrics
package checkmgr

import (
        "crypto/tls"
        "crypto/x509"
        "errors"
        "fmt"
        "io/ioutil"
        "log"
        "net/url"
        "os"
        "path"
        "strconv"
        "strings"
        "sync"
        "time"

        "github.com/circonus-labs/circonus-gometrics/api"
)

// Check management offers:
//
// Create a check if one cannot be found matching specific criteria
// Manage metrics in the supplied check (enabling new metrics as they are submitted)
//
// To disable check management, leave Config.Api.Token.Key blank
//
// use cases:
// configure without api token - check management disabled
//  - configuration parameters other than Check.SubmissionUrl, Debug and Log are ignored
//  - note: SubmissionUrl is **required** in this case as there is no way to derive w/o api
// configure with api token - check management enabled
//  - all otehr configuration parameters affect how the trap url is obtained
//    1. provided (Check.SubmissionUrl)
//    2. via check lookup (CheckConfig.Id)
//    3. via a search using CheckConfig.InstanceId + CheckConfig.SearchTag
//    4. a new check is created

const (
        defaultCheckType             = "httptrap"
        defaultTrapMaxURLAge         = "60s"   // 60 seconds
        defaultBrokerMaxResponseTime = "500ms" // 500 milliseconds
        defaultForceMetricActivation = "false"
        statusActive                 = "active"
)

// CheckConfig options for check
type CheckConfig struct {
        // a specific submission url
        SubmissionURL string
        // a specific check id (not check bundle id)
        ID string
        // unique instance id string
        // used to search for a check to use
        // used as check.target when creating a check
        InstanceID string
        // explicitly set check.target (default: instance id)
        TargetHost string
        // a custom display name for the check (as viewed in UI Checks)
        // default: instance id
        DisplayName string
        // unique check searching tag (or tags)
        // used to search for a check to use (combined with instanceid)
        // used as a regular tag when creating a check
        SearchTag string
        // httptrap check secret (for creating a check)
        Secret string
        // additional tags to add to a check (when creating a check)
        // these tags will not be added to an existing check
        Tags string
        // max amount of time to to hold on to a submission url
        // when a given submission fails (due to retries) if the
        // time the url was last updated is &gt; than this, the trap
        // url will be refreshed (e.g. if the broker is changed
        // in the UI) **only relevant when check management is enabled**
        // e.g. 5m, 30m, 1h, etc.
        MaxURLAge string
        // force metric activation - if a metric has been disabled via the UI
        // the default behavior is to *not* re-activate the metric; this setting
        // overrides the behavior and will re-activate the metric when it is
        // encountered. "(true|false)", default "false"
        ForceMetricActivation string
        // Type of check to use (default: httptrap)
        Type string
        // Custom check config fields (default: none)
        CustomConfigFields map[string]string
}

// BrokerConfig options for broker
type BrokerConfig struct {
        // a specific broker id (numeric portion of cid)
        ID string
        // one or more tags used to select 1-n brokers from which to select
        // when creating a new check (e.g. datacenter:abc or loc:dfw,dc:abc)
        SelectTag string
        // for a broker to be considered viable it must respond to a
        // connection attempt within this amount of time e.g. 200ms, 2s, 1m
        MaxResponseTime string
}

// Config options
type Config struct {
        Log   *log.Logger
        Debug bool

        // Circonus API config
        API api.Config
        // Check specific configuration options
        Check CheckConfig
        // Broker specific configuration options
        Broker BrokerConfig
}

// CheckTypeType check type
type CheckTypeType string

// CheckInstanceIDType check instance id
type CheckInstanceIDType string

// CheckTargetType check target/host
type CheckTargetType string

// CheckSecretType check secret
type CheckSecretType string

// CheckTagsType check tags
type CheckTagsType string

// CheckDisplayNameType check display name
type CheckDisplayNameType string

// BrokerCNType broker common name
type BrokerCNType string

// CheckManager settings
type CheckManager struct {
        enabled bool
        Log     *log.Logger
        Debug   bool
        apih    *api.API

        initialized   bool
        initializedmu sync.RWMutex

        // check
        checkType             CheckTypeType
        checkID               api.IDType
        checkInstanceID       CheckInstanceIDType
        checkTarget           CheckTargetType
        checkSearchTag        api.TagType
        checkSecret           CheckSecretType
        checkTags             api.TagType
        customConfigFields    map[string]string
        checkSubmissionURL    api.URLType
        checkDisplayName      CheckDisplayNameType
        forceMetricActivation bool
        forceCheckUpdate      bool

        // metric tags
        metricTags map[string][]string
        mtmu       sync.Mutex

        // broker
        brokerID              api.IDType
        brokerSelectTag       api.TagType
        brokerMaxResponseTime time.Duration

        // state
        checkBundle        *api.CheckBundle
        cbmu               sync.Mutex
        availableMetrics   map[string]bool
        availableMetricsmu sync.Mutex
        trapURL            api.URLType
        trapCN             BrokerCNType
        trapLastUpdate     time.Time
        trapMaxURLAge      time.Duration
        trapmu             sync.Mutex
        certPool           *x509.CertPool
}

// Trap config
type Trap struct {
        URL *url.URL
        TLS *tls.Config
}

// NewCheckManager returns a new check manager
func NewCheckManager(cfg *Config) (*CheckManager, error) <span class="cov10" title="5">{
        return New(cfg)
}</span>

// New returns a new check manager
func New(cfg *Config) (*CheckManager, error) <span class="cov10" title="5">{

        if cfg == nil </span><span class="cov1" title="1">{
                return nil, errors.New("invalid Check Manager configuration (nil)")
        }</span>

        <span class="cov8" title="4">cm := &amp;CheckManager{enabled: true, initialized: false}

        // Setup logging for check manager
        cm.Debug = cfg.Debug
        cm.Log = cfg.Log
        if cm.Debug &amp;&amp; cm.Log == nil </span><span class="cov0" title="0">{
                cm.Log = log.New(os.Stderr, "", log.LstdFlags)
        }</span>
        <span class="cov8" title="4">if cm.Log == nil </span><span class="cov7" title="3">{
                cm.Log = log.New(ioutil.Discard, "", log.LstdFlags)
        }</span>

        <span class="cov8" title="4">if cfg.Check.SubmissionURL != "" </span><span class="cov4" title="2">{
                cm.checkSubmissionURL = api.URLType(cfg.Check.SubmissionURL)
        }</span>

        // Blank API Token *disables* check management
        <span class="cov8" title="4">if cfg.API.TokenKey == "" </span><span class="cov7" title="3">{
                cm.enabled = false
        }</span>

        <span class="cov8" title="4">if !cm.enabled &amp;&amp; cm.checkSubmissionURL == "" </span><span class="cov1" title="1">{
                return nil, errors.New("invalid check manager configuration (no API token AND no submission url)")
        }</span>

        <span class="cov7" title="3">if cm.enabled </span><span class="cov1" title="1">{
                // initialize api handle
                cfg.API.Debug = cm.Debug
                cfg.API.Log = cm.Log
                apih, err := api.New(&amp;cfg.API)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov1" title="1">cm.apih = apih</span>
        }

        // initialize check related data
        <span class="cov7" title="3">if cfg.Check.Type != "" </span><span class="cov0" title="0">{
                cm.checkType = CheckTypeType(cfg.Check.Type)
        }</span><span class="cov7" title="3"> else {
                cm.checkType = defaultCheckType
        }</span>

        <span class="cov7" title="3">idSetting := "0"
        if cfg.Check.ID != "" </span><span class="cov0" title="0">{
                idSetting = cfg.Check.ID
        }</span>
        <span class="cov7" title="3">id, err := strconv.Atoi(idSetting)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov7" title="3">cm.checkID = api.IDType(id)

        cm.checkInstanceID = CheckInstanceIDType(cfg.Check.InstanceID)
        cm.checkTarget = CheckTargetType(cfg.Check.TargetHost)
        cm.checkDisplayName = CheckDisplayNameType(cfg.Check.DisplayName)
        cm.checkSecret = CheckSecretType(cfg.Check.Secret)

        fma := defaultForceMetricActivation
        if cfg.Check.ForceMetricActivation != "" </span><span class="cov0" title="0">{
                fma = cfg.Check.ForceMetricActivation
        }</span>
        <span class="cov7" title="3">fm, err := strconv.ParseBool(fma)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov7" title="3">cm.forceMetricActivation = fm

        _, an := path.Split(os.Args[0])
        hn, err := os.Hostname()
        if err != nil </span><span class="cov0" title="0">{
                hn = "unknown"
        }</span>
        <span class="cov7" title="3">if cm.checkInstanceID == "" </span><span class="cov7" title="3">{
                cm.checkInstanceID = CheckInstanceIDType(fmt.Sprintf("%s:%s", hn, an))
        }</span>
        <span class="cov7" title="3">if cm.checkDisplayName == "" </span><span class="cov7" title="3">{
                cm.checkDisplayName = CheckDisplayNameType(cm.checkInstanceID)
        }</span>
        <span class="cov7" title="3">if cm.checkTarget == "" </span><span class="cov7" title="3">{
                cm.checkTarget = CheckTargetType(cm.checkInstanceID)
        }</span>

        <span class="cov7" title="3">if cfg.Check.SearchTag == "" </span><span class="cov7" title="3">{
                cm.checkSearchTag = []string{fmt.Sprintf("service:%s", an)}
        }</span><span class="cov0" title="0"> else {
                cm.checkSearchTag = strings.Split(strings.Replace(cfg.Check.SearchTag, " ", "", -1), ",")
        }</span>

        <span class="cov7" title="3">if cfg.Check.Tags != "" </span><span class="cov0" title="0">{
                cm.checkTags = strings.Split(strings.Replace(cfg.Check.Tags, " ", "", -1), ",")
        }</span>

        <span class="cov7" title="3">cm.customConfigFields = make(map[string]string)
        if len(cfg.Check.CustomConfigFields) &gt; 0 </span><span class="cov0" title="0">{
                for fld, val := range cfg.Check.CustomConfigFields </span><span class="cov0" title="0">{
                        cm.customConfigFields[fld] = val
                }</span>
        }

        <span class="cov7" title="3">dur := cfg.Check.MaxURLAge
        if dur == "" </span><span class="cov7" title="3">{
                dur = defaultTrapMaxURLAge
        }</span>
        <span class="cov7" title="3">maxDur, err := time.ParseDuration(dur)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov7" title="3">cm.trapMaxURLAge = maxDur

        // setup broker
        idSetting = "0"
        if cfg.Broker.ID != "" </span><span class="cov0" title="0">{
                idSetting = cfg.Broker.ID
        }</span>
        <span class="cov7" title="3">id, err = strconv.Atoi(idSetting)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov7" title="3">cm.brokerID = api.IDType(id)

        if cfg.Broker.SelectTag != "" </span><span class="cov0" title="0">{
                cm.brokerSelectTag = strings.Split(strings.Replace(cfg.Broker.SelectTag, " ", "", -1), ",")
        }</span>

        <span class="cov7" title="3">dur = cfg.Broker.MaxResponseTime
        if dur == "" </span><span class="cov7" title="3">{
                dur = defaultBrokerMaxResponseTime
        }</span>
        <span class="cov7" title="3">maxDur, err = time.ParseDuration(dur)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov7" title="3">cm.brokerMaxResponseTime = maxDur

        // metrics
        cm.availableMetrics = make(map[string]bool)
        cm.metricTags = make(map[string][]string)

        return cm, nil</span>
}

// Initialize for sending metrics
func (cm *CheckManager) Initialize() <span class="cov7" title="3">{

        // if not managing the check, quicker initialization
        if !cm.enabled </span><span class="cov4" title="2">{
                err := cm.initializeTrapURL()
                if err == nil </span><span class="cov4" title="2">{
                        cm.initializedmu.Lock()
                        cm.initialized = true
                        cm.initializedmu.Unlock()
                }</span><span class="cov0" title="0"> else {
                        cm.Log.Printf("[WARN] error initializing trap %s", err.Error())
                }</span>
                <span class="cov4" title="2">return</span>
        }

        // background initialization when we have to reach out to the api
        <span class="cov1" title="1">go func() </span><span class="cov1" title="1">{
                cm.apih.EnableExponentialBackoff()
                err := cm.initializeTrapURL()
                if err == nil </span><span class="cov1" title="1">{
                        cm.initializedmu.Lock()
                        cm.initialized = true
                        cm.initializedmu.Unlock()
                }</span><span class="cov0" title="0"> else {
                        cm.Log.Printf("[WARN] error initializing trap %s", err.Error())
                }</span>
                <span class="cov1" title="1">cm.apih.DisableExponentialBackoff()</span>
        }()
}

// IsReady reflects if the check has been initialied and metrics can be sent to Circonus
func (cm *CheckManager) IsReady() bool <span class="cov8" title="4">{
        cm.initializedmu.RLock()
        defer cm.initializedmu.RUnlock()
        return cm.initialized
}</span>

// GetSubmissionURL returns submission url for circonus
func (cm *CheckManager) GetSubmissionURL() (*Trap, error) <span class="cov7" title="3">{
        if cm.trapURL == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("[ERROR] no submission url currently available")
                // if err := cm.initializeTrapURL(); err != nil {
                //         return nil, err
                // }
        }</span>

        <span class="cov7" title="3">trap := &amp;Trap{}

        u, err := url.Parse(string(cm.trapURL))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov7" title="3">trap.URL = u

        if u.Scheme == "https" </span><span class="cov4" title="2">{
                if cm.certPool == nil </span><span class="cov1" title="1">{
                        if err := cm.loadCACert(); err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                }
                <span class="cov4" title="2">t := &amp;tls.Config{
                        RootCAs: cm.certPool,
                }
                if cm.trapCN != "" </span><span class="cov1" title="1">{
                        t.ServerName = string(cm.trapCN)
                }</span>
                <span class="cov4" title="2">trap.TLS = t</span>
        }

        <span class="cov7" title="3">return trap, nil</span>
}

// ResetTrap URL, force request to the API for the submission URL and broker ca cert
func (cm *CheckManager) ResetTrap() error <span class="cov0" title="0">{
        if cm.trapURL == "" </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">cm.trapURL = ""
        cm.certPool = nil
        err := cm.initializeTrapURL()
        return err</span>
}

// RefreshTrap check when the last time the URL was reset, reset if needed
func (cm *CheckManager) RefreshTrap() <span class="cov0" title="0">{
        if cm.trapURL == "" </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">if time.Since(cm.trapLastUpdate) &gt;= cm.trapMaxURLAge </span><span class="cov0" title="0">{
                cm.ResetTrap()
        }</span>
}
</pre>
		
		<pre class="file" id="file25" style="display: none">// Copyright 2016 Circonus, Inc. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package checkmgr

import (
        "github.com/circonus-labs/circonus-gometrics/api"
)

// IsMetricActive checks whether a given metric name is currently active(enabled)
func (cm *CheckManager) IsMetricActive(name string) bool <span class="cov4" title="3">{
        cm.availableMetricsmu.Lock()
        defer cm.availableMetricsmu.Unlock()

        active, _ := cm.availableMetrics[name]
        return active
}</span>

// ActivateMetric determines if a given metric should be activated
func (cm *CheckManager) ActivateMetric(name string) bool <span class="cov5" title="4">{
        cm.availableMetricsmu.Lock()
        defer cm.availableMetricsmu.Unlock()

        active, exists := cm.availableMetrics[name]

        if !exists </span><span class="cov1" title="1">{
                return true
        }</span>

        <span class="cov4" title="3">if !active &amp;&amp; cm.forceMetricActivation </span><span class="cov1" title="1">{
                return true
        }</span>

        <span class="cov3" title="2">return false</span>
}

// AddMetricTags updates check bundle metrics with tags
func (cm *CheckManager) AddMetricTags(metricName string, tags []string, appendTags bool) bool <span class="cov9" title="13">{
        tagsUpdated := false

        if appendTags &amp;&amp; len(tags) == 0 </span><span class="cov1" title="1">{
                return tagsUpdated
        }</span>

        <span class="cov9" title="12">currentTags, exists := cm.metricTags[metricName]
        if !exists </span><span class="cov6" title="6">{
                foundMetric := false

                if cm.checkBundle != nil </span><span class="cov6" title="6">{
                        for _, metric := range cm.checkBundle.Metrics </span><span class="cov8" title="9">{
                                if metric.Name == metricName </span><span class="cov5" title="4">{
                                        foundMetric = true
                                        currentTags = metric.Tags
                                        break</span>
                                }
                        }
                }

                <span class="cov6" title="6">if !foundMetric </span><span class="cov3" title="2">{
                        currentTags = []string{}
                }</span>
        }

        <span class="cov9" title="12">action := ""
        if appendTags </span><span class="cov6" title="5">{
                numNewTags := countNewTags(currentTags, tags)
                if numNewTags &gt; 0 </span><span class="cov3" title="2">{
                        action = "Added"
                        currentTags = append(currentTags, tags...)
                        tagsUpdated = true
                }</span>
        }<span class="cov7" title="7"> else {
                if len(tags) != len(currentTags) </span><span class="cov5" title="4">{
                        action = "Set"
                        currentTags = tags
                        tagsUpdated = true
                }</span><span class="cov4" title="3"> else {
                        numNewTags := countNewTags(currentTags, tags)
                        if numNewTags &gt; 0 </span><span class="cov1" title="1">{
                                action = "Set"
                                currentTags = tags
                                tagsUpdated = true
                        }</span>
                }
        }

        <span class="cov9" title="12">if tagsUpdated </span><span class="cov7" title="7">{
                cm.metricTags[metricName] = currentTags
        }</span>

        <span class="cov9" title="12">if cm.Debug &amp;&amp; action != "" </span><span class="cov0" title="0">{
                cm.Log.Printf("[DEBUG] %s metric tag(s) %s %v\n", action, metricName, tags)
        }</span>

        <span class="cov9" title="12">return tagsUpdated</span>
}

// addNewMetrics updates a check bundle with new metrics
func (cm *CheckManager) addNewMetrics(newMetrics map[string]*api.CheckBundleMetric) bool <span class="cov5" title="4">{
        updatedCheckBundle := false

        if cm.checkBundle == nil || len(newMetrics) == 0 </span><span class="cov1" title="1">{
                return updatedCheckBundle
        }</span>

        <span class="cov4" title="3">cm.cbmu.Lock()
        defer cm.cbmu.Unlock()

        numCurrMetrics := len(cm.checkBundle.Metrics)
        numNewMetrics := len(newMetrics)

        if numCurrMetrics+numNewMetrics &gt;= cap(cm.checkBundle.Metrics) </span><span class="cov1" title="1">{
                nm := make([]api.CheckBundleMetric, numCurrMetrics+numNewMetrics)
                copy(nm, cm.checkBundle.Metrics)
                cm.checkBundle.Metrics = nm
        }</span>

        <span class="cov4" title="3">cm.checkBundle.Metrics = cm.checkBundle.Metrics[0 : numCurrMetrics+numNewMetrics]

        i := 0
        for _, metric := range newMetrics </span><span class="cov4" title="3">{
                cm.checkBundle.Metrics[numCurrMetrics+i] = *metric
                i++
                updatedCheckBundle = true
        }</span>

        <span class="cov4" title="3">if updatedCheckBundle </span><span class="cov4" title="3">{
                cm.forceCheckUpdate = true
        }</span>

        <span class="cov4" title="3">return updatedCheckBundle</span>
}

// inventoryMetrics creates list of active metrics in check bundle
func (cm *CheckManager) inventoryMetrics() <span class="cov8" title="11">{
        availableMetrics := make(map[string]bool)
        for _, metric := range cm.checkBundle.Metrics </span><span class="cov10" title="15">{
                availableMetrics[metric.Name] = metric.Status == "active"
        }</span>
        <span class="cov8" title="11">cm.availableMetricsmu.Lock()
        cm.availableMetrics = availableMetrics
        cm.availableMetricsmu.Unlock()</span>
}

// countNewTags returns a count of new tags which do not exist in the current list of tags
func countNewTags(currTags []string, newTags []string) int <span class="cov7" title="8">{
        if len(newTags) == 0 </span><span class="cov1" title="1">{
                return 0
        }</span>

        <span class="cov7" title="7">if len(currTags) == 0 </span><span class="cov1" title="1">{
                return len(newTags)
        }</span>

        <span class="cov6" title="6">newTagCount := 0

        for _, newTag := range newTags </span><span class="cov6" title="6">{
                found := false
                for _, currTag := range currTags </span><span class="cov7" title="7">{
                        if newTag == currTag </span><span class="cov5" title="4">{
                                found = true
                                break</span>
                        }
                }
                <span class="cov6" title="6">if !found </span><span class="cov3" title="2">{
                        newTagCount++
                }</span>
        }

        <span class="cov6" title="6">return newTagCount</span>
}
</pre>
		
		<pre class="file" id="file26" style="display: none">// Copyright 2016 Circonus, Inc. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Package circonusgometrics provides instrumentation for your applications in the form
// of counters, gauges and histograms and allows you to publish them to
// Circonus
//
// Counters
//
// A counter is a monotonically-increasing, unsigned, 64-bit integer used to
// represent the number of times an event has occurred. By tracking the deltas
// between measurements of a counter over intervals of time, an aggregation
// layer can derive rates, acceleration, etc.
//
// Gauges
//
// A gauge returns instantaneous measurements of something using signed, 64-bit
// integers. This value does not need to be monotonic.
//
// Histograms
//
// A histogram tracks the distribution of a stream of values (e.g. the number of
// seconds it takes to handle requests).  Circonus can calculate complex
// analytics on these.
//
// Reporting
//
// A period push to a Circonus httptrap is confgurable.
package circonusgometrics

import (
        "errors"
        "io/ioutil"
        "log"
        "os"
        "strconv"
        "sync"
        "time"

        "github.com/circonus-labs/circonus-gometrics/api"
        "github.com/circonus-labs/circonus-gometrics/checkmgr"
)

const (
        defaultFlushInterval = "10s" // 10 * time.Second
)

// Metric defines an individual metric
type Metric struct {
        Type  string      `json:"_type"`
        Value interface{} `json:"_value"`
}

// Metrics holds host metrics
type Metrics map[string]Metric

// Config options for circonus-gometrics
type Config struct {
        Log             *log.Logger
        Debug           bool
        ResetCounters   string // reset/delete counters on flush (default true)
        ResetGauges     string // reset/delete gauges on flush (default true)
        ResetHistograms string // reset/delete histograms on flush (default true)
        ResetText       string // reset/delete text on flush (default true)

        // API, Check and Broker configuration options
        CheckManager checkmgr.Config

        // how frequenly to submit metrics to Circonus, default 10 seconds.
        // Set to 0 to disable automatic flushes and call Flush manually.
        Interval string
}

// CirconusMetrics state
type CirconusMetrics struct {
        Log   *log.Logger
        Debug bool

        resetCounters   bool
        resetGauges     bool
        resetHistograms bool
        resetText       bool
        flushInterval   time.Duration
        flushing        bool
        flushmu         sync.Mutex
        packagingmu     sync.Mutex
        check           *checkmgr.CheckManager

        counters map[string]uint64
        cm       sync.Mutex

        counterFuncs map[string]func() uint64
        cfm          sync.Mutex

        gauges map[string]string
        gm     sync.Mutex

        gaugeFuncs map[string]func() int64
        gfm        sync.Mutex

        histograms map[string]*Histogram
        hm         sync.Mutex

        text map[string]string
        tm   sync.Mutex

        textFuncs map[string]func() string
        tfm       sync.Mutex
}

// NewCirconusMetrics returns a CirconusMetrics instance
func NewCirconusMetrics(cfg *Config) (*CirconusMetrics, error) <span class="cov7" title="15">{
        return New(cfg)
}</span>

// New returns a CirconusMetrics instance
func New(cfg *Config) (*CirconusMetrics, error) <span class="cov10" title="33">{

        if cfg == nil </span><span class="cov1" title="1">{
                return nil, errors.New("invalid configuration (nil)")
        }</span>

        <span class="cov9" title="32">cm := &amp;CirconusMetrics{
                counters:     make(map[string]uint64),
                counterFuncs: make(map[string]func() uint64),
                gauges:       make(map[string]string),
                gaugeFuncs:   make(map[string]func() int64),
                histograms:   make(map[string]*Histogram),
                text:         make(map[string]string),
                textFuncs:    make(map[string]func() string),
        }

        // Logging
        </span><span class="cov9" title="32">{
                cm.Debug = cfg.Debug
                cm.Log = cfg.Log

                if cm.Debug &amp;&amp; cm.Log == nil </span><span class="cov1" title="1">{
                        cm.Log = log.New(os.Stderr, "", log.LstdFlags)
                }</span>
                <span class="cov9" title="32">if cm.Log == nil </span><span class="cov9" title="31">{
                        cm.Log = log.New(ioutil.Discard, "", log.LstdFlags)
                }</span>
        }

        // Flush Interval
        <span class="cov9" title="32">{
                fi := defaultFlushInterval
                if cfg.Interval != "" </span><span class="cov6" title="9">{
                        fi = cfg.Interval
                }</span>

                <span class="cov9" title="32">dur, err := time.ParseDuration(fi)
                if err != nil </span><span class="cov1" title="1">{
                        return nil, err
                }</span>
                <span class="cov9" title="31">cm.flushInterval = dur</span>
        }

        // metric resets

        <span class="cov9" title="31">cm.resetCounters = true
        if cfg.ResetCounters != "" </span><span class="cov3" title="3">{
                setting, err := strconv.ParseBool(cfg.ResetCounters)
                if err != nil </span><span class="cov1" title="1">{
                        return nil, err
                }</span>
                <span class="cov2" title="2">cm.resetCounters = setting</span>
        }

        <span class="cov9" title="30">cm.resetGauges = true
        if cfg.ResetGauges != "" </span><span class="cov3" title="3">{
                setting, err := strconv.ParseBool(cfg.ResetGauges)
                if err != nil </span><span class="cov1" title="1">{
                        return nil, err
                }</span>
                <span class="cov2" title="2">cm.resetGauges = setting</span>
        }

        <span class="cov9" title="29">cm.resetHistograms = true
        if cfg.ResetHistograms != "" </span><span class="cov3" title="3">{
                setting, err := strconv.ParseBool(cfg.ResetHistograms)
                if err != nil </span><span class="cov1" title="1">{
                        return nil, err
                }</span>
                <span class="cov2" title="2">cm.resetHistograms = setting</span>
        }

        <span class="cov9" title="28">cm.resetText = true
        if cfg.ResetText != "" </span><span class="cov3" title="3">{
                setting, err := strconv.ParseBool(cfg.ResetText)
                if err != nil </span><span class="cov1" title="1">{
                        return nil, err
                }</span>
                <span class="cov2" title="2">cm.resetText = setting</span>
        }

        // check manager
        <span class="cov9" title="27">{
                cfg.CheckManager.Debug = cm.Debug
                cfg.CheckManager.Log = cm.Log

                check, err := checkmgr.New(&amp;cfg.CheckManager)
                if err != nil </span><span class="cov1" title="1">{
                        return nil, err
                }</span>
                <span class="cov9" title="26">cm.check = check</span>
        }

        // start background initialization
        <span class="cov9" title="26">cm.check.Initialize()

        // if automatic flush is enabled, start it.
        // note: submit will jettison metrics until initialization has completed.
        if cm.flushInterval &gt; time.Duration(0) </span><span class="cov8" title="19">{
                go func() </span><span class="cov8" title="19">{
                        for range time.NewTicker(cm.flushInterval).C </span><span class="cov0" title="0">{
                                cm.Flush()
                        }</span>
                }()
        }

        <span class="cov9" title="26">return cm, nil</span>
}

// Start deprecated NOP, automatic flush is started in New if flush interval &gt; 0.
func (m *CirconusMetrics) Start() <span class="cov0" title="0">{
        return
}</span>

// Ready returns true or false indicating if the check is ready to accept metrics
func (m *CirconusMetrics) Ready() bool <span class="cov0" title="0">{
        return m.check.IsReady()
}</span>

func (m *CirconusMetrics) packageMetrics() (map[string]*api.CheckBundleMetric, Metrics) <span class="cov7" title="11">{

        m.packagingmu.Lock()
        defer m.packagingmu.Unlock()

        if m.Debug </span><span class="cov0" title="0">{
                m.Log.Println("[DEBUG] Packaging metrics")
        }</span>

        <span class="cov7" title="11">counters, gauges, histograms, text := m.snapshot()
        newMetrics := make(map[string]*api.CheckBundleMetric)
        output := make(Metrics, len(counters)+len(gauges)+len(histograms)+len(text))
        for name, value := range counters </span><span class="cov2" title="2">{
                send := m.check.IsMetricActive(name)
                if !send &amp;&amp; m.check.ActivateMetric(name) </span><span class="cov2" title="2">{
                        send = true
                        newMetrics[name] = &amp;api.CheckBundleMetric{
                                Name:   name,
                                Type:   "numeric",
                                Status: "active",
                        }
                }</span>
                <span class="cov2" title="2">if send </span><span class="cov2" title="2">{
                        output[name] = Metric{Type: "L", Value: value}
                }</span>
        }

        <span class="cov7" title="11">for name, value := range gauges </span><span class="cov2" title="2">{
                send := m.check.IsMetricActive(name)
                if !send &amp;&amp; m.check.ActivateMetric(name) </span><span class="cov2" title="2">{
                        send = true
                        newMetrics[name] = &amp;api.CheckBundleMetric{
                                Name:   name,
                                Type:   "numeric",
                                Status: "active",
                        }
                }</span>
                <span class="cov2" title="2">if send </span><span class="cov2" title="2">{
                        output[name] = Metric{Type: "n", Value: value}
                }</span>
        }

        <span class="cov7" title="11">for name, value := range histograms </span><span class="cov2" title="2">{
                send := m.check.IsMetricActive(name)
                if !send &amp;&amp; m.check.ActivateMetric(name) </span><span class="cov2" title="2">{
                        send = true
                        newMetrics[name] = &amp;api.CheckBundleMetric{
                                Name:   name,
                                Type:   "histogram",
                                Status: "active",
                        }
                }</span>
                <span class="cov2" title="2">if send </span><span class="cov2" title="2">{
                        output[name] = Metric{Type: "n", Value: value.DecStrings()}
                }</span>
        }

        <span class="cov7" title="11">for name, value := range text </span><span class="cov2" title="2">{
                send := m.check.IsMetricActive(name)
                if !send &amp;&amp; m.check.ActivateMetric(name) </span><span class="cov2" title="2">{
                        send = true
                        newMetrics[name] = &amp;api.CheckBundleMetric{
                                Name:   name,
                                Type:   "text",
                                Status: "active",
                        }
                }</span>
                <span class="cov2" title="2">if send </span><span class="cov2" title="2">{
                        output[name] = Metric{Type: "s", Value: value}
                }</span>
        }

        <span class="cov7" title="11">return newMetrics, output</span>
}

// FlushMetrics flushes current metrics to a structure and returns it (does NOT send to Circonus)
func (m *CirconusMetrics) FlushMetrics() *Metrics <span class="cov5" title="6">{
        m.flushmu.Lock()
        if m.flushing </span><span class="cov1" title="1">{
                m.flushmu.Unlock()
                return &amp;Metrics{}
        }</span>

        <span class="cov5" title="5">m.flushing = true
        m.flushmu.Unlock()

        _, output := m.packageMetrics()

        m.flushmu.Lock()
        m.flushing = false
        m.flushmu.Unlock()

        return &amp;output</span>
}

// Flush metrics kicks off the process of sending metrics to Circonus
func (m *CirconusMetrics) Flush() <span class="cov5" title="6">{
        m.flushmu.Lock()
        if m.flushing </span><span class="cov1" title="1">{
                m.flushmu.Unlock()
                return
        }</span>

        <span class="cov5" title="5">m.flushing = true
        m.flushmu.Unlock()

        newMetrics, output := m.packageMetrics()

        if len(output) &gt; 0 </span><span class="cov4" title="4">{
                m.submit(output, newMetrics)
        }</span><span class="cov1" title="1"> else {
                if m.Debug </span><span class="cov0" title="0">{
                        m.Log.Println("[DEBUG] No metrics to send, skipping")
                }</span>
        }

        <span class="cov5" title="5">m.flushmu.Lock()
        m.flushing = false
        m.flushmu.Unlock()</span>
}
</pre>
		
		<pre class="file" id="file27" style="display: none">// Copyright 2016 Circonus, Inc. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package circonusgometrics

import "fmt"

// A Counter is a monotonically increasing unsigned integer.
//
// Use a counter to derive rates (e.g., record total number of requests, derive
// requests per second).

// Increment counter by 1
func (m *CirconusMetrics) Increment(metric string) <span class="cov7" title="4">{
        m.Add(metric, 1)
}</span>

// IncrementByValue updates counter by supplied value
func (m *CirconusMetrics) IncrementByValue(metric string, val uint64) <span class="cov1" title="1">{
        m.Add(metric, val)
}</span>

// Set a counter to specific value
func (m *CirconusMetrics) Set(metric string, val uint64) <span class="cov9" title="5">{
        m.cm.Lock()
        defer m.cm.Unlock()
        m.counters[metric] = val
}</span>

// Add updates counter by supplied value
func (m *CirconusMetrics) Add(metric string, val uint64) <span class="cov10" title="6">{
        m.cm.Lock()
        defer m.cm.Unlock()
        m.counters[metric] += val
}</span>

// RemoveCounter removes the named counter
func (m *CirconusMetrics) RemoveCounter(metric string) <span class="cov1" title="1">{
        m.cm.Lock()
        defer m.cm.Unlock()
        delete(m.counters, metric)
}</span>

// GetCounterTest returns the current value for a counter. (note: it is a function specifically for "testing", disable automatic submission during testing.)
func (m *CirconusMetrics) GetCounterTest(metric string) (uint64, error) <span class="cov4" title="2">{
        m.cm.Lock()
        defer m.cm.Unlock()

        if val, ok := m.counters[metric]; ok </span><span class="cov1" title="1">{
                return val, nil
        }</span>

        <span class="cov1" title="1">return 0, fmt.Errorf("Counter metric '%s' not found", metric)</span>

}

// SetCounterFunc set counter to a function [called at flush interval]
func (m *CirconusMetrics) SetCounterFunc(metric string, fn func() uint64) <span class="cov4" title="2">{
        m.cfm.Lock()
        defer m.cfm.Unlock()
        m.counterFuncs[metric] = fn
}</span>

// RemoveCounterFunc removes the named counter function
func (m *CirconusMetrics) RemoveCounterFunc(metric string) <span class="cov1" title="1">{
        m.cfm.Lock()
        defer m.cfm.Unlock()
        delete(m.counterFuncs, metric)
}</span>
</pre>
		
		<pre class="file" id="file28" style="display: none">// Copyright 2016 Circonus, Inc. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package circonusgometrics

// A Gauge is an instantaneous measurement of a value.
//
// Use a gauge to track metrics which increase and decrease (e.g., amount of
// free memory).

import (
        "fmt"
)

// Gauge sets a gauge to a value
func (m *CirconusMetrics) Gauge(metric string, val interface{}) <span class="cov9" title="15">{
        m.SetGauge(metric, val)
}</span>

// SetGauge sets a gauge to a value
func (m *CirconusMetrics) SetGauge(metric string, val interface{}) <span class="cov10" title="19">{
        m.gm.Lock()
        defer m.gm.Unlock()
        m.gauges[metric] = m.gaugeValString(val)
}</span>

// RemoveGauge removes a gauge
func (m *CirconusMetrics) RemoveGauge(metric string) <span class="cov1" title="1">{
        m.gm.Lock()
        defer m.gm.Unlock()
        delete(m.gauges, metric)
}</span>

// GetGaugeTest returns the current value for a gauge. (note: it is a function specifically for "testing", disable automatic submission during testing.)
func (m *CirconusMetrics) GetGaugeTest(metric string) (string, error) <span class="cov3" title="2">{
        m.gm.Lock()
        defer m.gm.Unlock()

        if val, ok := m.gauges[metric]; ok </span><span class="cov1" title="1">{
                return val, nil
        }</span>

        <span class="cov1" title="1">return "", fmt.Errorf("Gauge metric '%s' not found", metric)</span>
}

// SetGaugeFunc sets a gauge to a function [called at flush interval]
func (m *CirconusMetrics) SetGaugeFunc(metric string, fn func() int64) <span class="cov3" title="2">{
        m.gfm.Lock()
        defer m.gfm.Unlock()
        m.gaugeFuncs[metric] = fn
}</span>

// RemoveGaugeFunc removes a gauge function
func (m *CirconusMetrics) RemoveGaugeFunc(metric string) <span class="cov1" title="1">{
        m.gfm.Lock()
        defer m.gfm.Unlock()
        delete(m.gaugeFuncs, metric)
}</span>

// gaugeValString converts an interface value (of a supported type) to a string
func (m *CirconusMetrics) gaugeValString(val interface{}) string <span class="cov10" title="19">{
        vs := ""
        switch v := val.(type) </span>{
        default:</span><span class="cov0" title="0">
                // ignore it, unsupported type
        case int:<span class="cov7" title="8">
                vs = fmt.Sprintf("%d", v)</span>
        case int8:<span class="cov1" title="1">
                vs = fmt.Sprintf("%d", v)</span>
        case int16:<span class="cov1" title="1">
                vs = fmt.Sprintf("%d", v)</span>
        case int32:<span class="cov1" title="1">
                vs = fmt.Sprintf("%d", v)</span>
        case int64:<span class="cov1" title="1">
                vs = fmt.Sprintf("%d", v)</span>
        case uint:<span class="cov1" title="1">
                vs = fmt.Sprintf("%d", v)</span>
        case uint8:<span class="cov1" title="1">
                vs = fmt.Sprintf("%d", v)</span>
        case uint16:<span class="cov1" title="1">
                vs = fmt.Sprintf("%d", v)</span>
        case uint32:<span class="cov1" title="1">
                vs = fmt.Sprintf("%d", v)</span>
        case uint64:<span class="cov1" title="1">
                vs = fmt.Sprintf("%d", v)</span>
        case float32:<span class="cov1" title="1">
                vs = fmt.Sprintf("%f", v)</span>
        case float64:<span class="cov1" title="1">
                vs = fmt.Sprintf("%f", v)</span>
        }
        <span class="cov10" title="19">return vs</span>
}
</pre>
		
		<pre class="file" id="file29" style="display: none">// Copyright 2016 Circonus, Inc. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package circonusgometrics

import (
        "fmt"
        "sync"

        "github.com/circonus-labs/circonusllhist"
)

// Histogram measures the distribution of a stream of values.
type Histogram struct {
        name string
        hist *circonusllhist.Histogram
        rw   sync.RWMutex
}

// Timing adds a value to a histogram
func (m *CirconusMetrics) Timing(metric string, val float64) <span class="cov6" title="5">{
        m.SetHistogramValue(metric, val)
}</span>

// RecordValue adds a value to a histogram
func (m *CirconusMetrics) RecordValue(metric string, val float64) <span class="cov1" title="1">{
        m.SetHistogramValue(metric, val)
}</span>

// SetHistogramValue adds a value to a histogram
func (m *CirconusMetrics) SetHistogramValue(metric string, val float64) <span class="cov8" title="9">{
        hist := m.NewHistogram(metric)

        m.hm.Lock()
        hist.rw.Lock()
        hist.hist.RecordValue(val)
        hist.rw.Unlock()
        m.hm.Unlock()
}</span>

// GetHistogramTest returns the current value for a gauge. (note: it is a function specifically for "testing", disable automatic submission during testing.)
func (m *CirconusMetrics) GetHistogramTest(metric string) ([]string, error) <span class="cov3" title="2">{
        m.hm.Lock()
        defer m.hm.Unlock()

        if hist, ok := m.histograms[metric]; ok </span><span class="cov1" title="1">{
                return hist.hist.DecStrings(), nil
        }</span>

        <span class="cov1" title="1">return []string{""}, fmt.Errorf("Histogram metric '%s' not found", metric)</span>
}

// RemoveHistogram removes a histogram
func (m *CirconusMetrics) RemoveHistogram(metric string) <span class="cov1" title="1">{
        m.hm.Lock()
        delete(m.histograms, metric)
        m.hm.Unlock()
}</span>

// NewHistogram returns a histogram instance.
func (m *CirconusMetrics) NewHistogram(metric string) *Histogram <span class="cov10" title="13">{
        m.hm.Lock()
        defer m.hm.Unlock()

        if hist, ok := m.histograms[metric]; ok </span><span class="cov1" title="1">{
                return hist
        }</span>

        <span class="cov9" title="12">hist := &amp;Histogram{
                name: metric,
                hist: circonusllhist.New(),
        }

        m.histograms[metric] = hist

        return hist</span>
}

// Name returns the name from a histogram instance
func (h *Histogram) Name() string <span class="cov1" title="1">{
        return h.name
}</span>

// RecordValue records the given value to a histogram instance
func (h *Histogram) RecordValue(v float64) <span class="cov1" title="1">{
        h.rw.Lock()
        h.hist.RecordValue(v)
        h.rw.Unlock()
}</span>
</pre>
		
		<pre class="file" id="file30" style="display: none">// Copyright 2016 Circonus, Inc. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package circonusgometrics

// SetMetricTags sets the tags for the named metric and flags a check update is needed
func (m *CirconusMetrics) SetMetricTags(name string, tags []string) bool <span class="cov0" title="0">{
        return m.check.AddMetricTags(name, tags, false)
}</span>

// AddMetricTags appends tags to any existing tags for the named metric and flags a check update is needed
func (m *CirconusMetrics) AddMetricTags(name string, tags []string) bool <span class="cov0" title="0">{
        return m.check.AddMetricTags(name, tags, true)
}</span>
</pre>
		
		<pre class="file" id="file31" style="display: none">// Copyright 2016 Circonus, Inc. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package circonusgometrics

import (
        "bytes"
        "encoding/json"
        "errors"
        "fmt"
        "io/ioutil"
        "log"
        "net"
        "net/http"
        "strconv"
        "time"

        "github.com/circonus-labs/circonus-gometrics/api"
        "github.com/hashicorp/go-retryablehttp"
)

func (m *CirconusMetrics) submit(output Metrics, newMetrics map[string]*api.CheckBundleMetric) <span class="cov9" title="5">{

        // if there is nowhere to send metrics to, just return.
        if !m.check.IsReady() </span><span class="cov0" title="0">{
                m.Log.Printf("[WARN] check not ready, skipping metric submission")
                return
        }</span>

        // update check if there are any new metrics or, if metric tags have been added since last submit
        <span class="cov9" title="5">m.check.UpdateCheck(newMetrics)

        str, err := json.Marshal(output)
        if err != nil </span><span class="cov0" title="0">{
                m.Log.Printf("[ERROR] marshaling output %+v", err)
                return
        }</span>

        <span class="cov9" title="5">numStats, err := m.trapCall(str)
        if err != nil </span><span class="cov7" title="4">{
                m.Log.Printf("[ERROR] %+v\n", err)
                return
        }</span>

        <span class="cov1" title="1">if m.Debug </span><span class="cov0" title="0">{
                m.Log.Printf("[DEBUG] %d stats sent\n", numStats)
        }</span>
}

func (m *CirconusMetrics) trapCall(payload []byte) (int, error) <span class="cov10" title="6">{
        trap, err := m.check.GetSubmissionURL()
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        <span class="cov10" title="6">dataReader := bytes.NewReader(payload)

        req, err := retryablehttp.NewRequest("PUT", trap.URL.String(), dataReader)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov10" title="6">req.Header.Add("Content-Type", "application/json")
        req.Header.Add("Accept", "application/json")

        // keep last HTTP error in the event of retry failure
        var lastHTTPError error
        retryPolicy := func(resp *http.Response, err error) (bool, error) </span><span class="cov10" title="6">{
                if err != nil </span><span class="cov0" title="0">{
                        lastHTTPError = err
                        return true, err
                }</span>
                // Check the response code. We retry on 500-range responses to allow
                // the server time to recover, as 500's are typically not permanent
                // errors and may relate to outages on the server side. This will catch
                // invalid response codes as well, like 0 and 999.
                <span class="cov10" title="6">if resp.StatusCode == 0 || resp.StatusCode &gt;= 500 </span><span class="cov0" title="0">{
                        body, readErr := ioutil.ReadAll(resp.Body)
                        if readErr != nil </span><span class="cov0" title="0">{
                                lastHTTPError = fmt.Errorf("- last HTTP error: %d %+v", resp.StatusCode, readErr)
                        }</span><span class="cov0" title="0"> else {
                                lastHTTPError = fmt.Errorf("- last HTTP error: %d %s", resp.StatusCode, string(body))
                        }</span>
                        <span class="cov0" title="0">return true, nil</span>
                }
                <span class="cov10" title="6">return false, nil</span>
        }

        <span class="cov10" title="6">client := retryablehttp.NewClient()
        if trap.URL.Scheme == "https" </span><span class="cov0" title="0">{
                client.HTTPClient.Transport = &amp;http.Transport{
                        Proxy: http.ProxyFromEnvironment,
                        Dial: (&amp;net.Dialer{
                                Timeout:   30 * time.Second,
                                KeepAlive: 30 * time.Second,
                        }).Dial,
                        TLSHandshakeTimeout: 10 * time.Second,
                        TLSClientConfig:     trap.TLS,
                        DisableKeepAlives:   true,
                        MaxIdleConnsPerHost: -1,
                        DisableCompression:  true,
                }
        }</span><span class="cov10" title="6"> else {
                client.HTTPClient.Transport = &amp;http.Transport{
                        Proxy: http.ProxyFromEnvironment,
                        Dial: (&amp;net.Dialer{
                                Timeout:   30 * time.Second,
                                KeepAlive: 30 * time.Second,
                        }).Dial,
                        TLSHandshakeTimeout: 10 * time.Second,
                        DisableKeepAlives:   true,
                        MaxIdleConnsPerHost: -1,
                        DisableCompression:  true,
                }
        }</span>
        <span class="cov10" title="6">client.RetryWaitMin = 1 * time.Second
        client.RetryWaitMax = 5 * time.Second
        client.RetryMax = 3
        // retryablehttp only groks log or no log
        // but, outputs everything as [DEBUG] messages
        if m.Debug </span><span class="cov0" title="0">{
                client.Logger = m.Log
        }</span><span class="cov10" title="6"> else {
                client.Logger = log.New(ioutil.Discard, "", log.LstdFlags)
        }</span>
        <span class="cov10" title="6">client.CheckRetry = retryPolicy

        attempts := -1
        client.RequestLogHook = func(logger *log.Logger, req *http.Request, retryNumber int) </span><span class="cov10" title="6">{
                attempts = retryNumber
        }</span>

        <span class="cov10" title="6">resp, err := client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                if lastHTTPError != nil </span><span class="cov0" title="0">{
                        return 0, fmt.Errorf("[ERROR] submitting: %+v %+v", err, lastHTTPError)
                }</span>
                <span class="cov0" title="0">if attempts == client.RetryMax </span><span class="cov0" title="0">{
                        m.check.RefreshTrap()
                }</span>
                <span class="cov0" title="0">return 0, err</span>
        }

        <span class="cov10" title="6">defer resp.Body.Close()

        // no content - expected result from circonus-agent when metrics accepted
        if resp.StatusCode == http.StatusNoContent </span><span class="cov0" title="0">{
                return -1, nil
        }</span>

        <span class="cov10" title="6">body, err := ioutil.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                m.Log.Printf("[ERROR] reading body, proceeding. %s\n", err)
        }</span>

        <span class="cov10" title="6">var response map[string]interface{}
        if err := json.Unmarshal(body, &amp;response); err != nil </span><span class="cov0" title="0">{
                m.Log.Printf("[ERROR] parsing body, proceeding. %v (%s)\n", err, body)
        }</span>

        <span class="cov10" title="6">if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                return 0, errors.New("[ERROR] bad response code: " + strconv.Itoa(resp.StatusCode))
        }</span>
        <span class="cov10" title="6">switch v := response["stats"].(type) </span>{
        case float64:<span class="cov4" title="2">
                return int(v), nil</span>
        case int:<span class="cov0" title="0">
                return v, nil</span>
        default:</span><span class="cov7" title="4">
        }
        <span class="cov7" title="4">return 0, errors.New("[ERROR] bad response type")</span>
}
</pre>
		
		<pre class="file" id="file32" style="display: none">// Copyright 2016 Circonus, Inc. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package circonusgometrics

// A Text metric is an arbitrary string
//

// SetText sets a text metric
func (m *CirconusMetrics) SetText(metric string, val string) <span class="cov9" title="6">{
        m.SetTextValue(metric, val)
}</span>

// SetTextValue sets a text metric
func (m *CirconusMetrics) SetTextValue(metric string, val string) <span class="cov10" title="7">{
        m.tm.Lock()
        defer m.tm.Unlock()
        m.text[metric] = val
}</span>

// RemoveText removes a text metric
func (m *CirconusMetrics) RemoveText(metric string) <span class="cov1" title="1">{
        m.tm.Lock()
        defer m.tm.Unlock()
        delete(m.text, metric)
}</span>

// SetTextFunc sets a text metric to a function [called at flush interval]
func (m *CirconusMetrics) SetTextFunc(metric string, fn func() string) <span class="cov4" title="2">{
        m.tfm.Lock()
        defer m.tfm.Unlock()
        m.textFuncs[metric] = fn
}</span>

// RemoveTextFunc a text metric function
func (m *CirconusMetrics) RemoveTextFunc(metric string) <span class="cov1" title="1">{
        m.tfm.Lock()
        defer m.tfm.Unlock()
        delete(m.textFuncs, metric)
}</span>
</pre>
		
		<pre class="file" id="file33" style="display: none">// Copyright 2016 Circonus, Inc. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package circonusgometrics

import (
        "net/http"
        "time"
)

// TrackHTTPLatency wraps Handler functions registered with an http.ServerMux tracking latencies.
// Metrics are of the for go`HTTP`&lt;method&gt;`&lt;name&gt;`latency and are tracked in a histogram in units
// of seconds (as a float64) providing nanosecond ganularity.
func (m *CirconusMetrics) TrackHTTPLatency(name string, handler func(http.ResponseWriter, *http.Request)) func(http.ResponseWriter, *http.Request) <span class="cov0" title="0">{
        return func(rw http.ResponseWriter, req *http.Request) </span><span class="cov0" title="0">{
                start := time.Now().UnixNano()
                handler(rw, req)
                elapsed := time.Now().UnixNano() - start
                //hist := m.NewHistogram("go`HTTP`" + req.Method + "`" + name + "`latency")
                m.RecordValue("go`HTTP`"+req.Method+"`"+name+"`latency", float64(elapsed)/float64(time.Second))
        }</span>
}
</pre>
		
		<pre class="file" id="file34" style="display: none">// Copyright 2016 Circonus, Inc. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package circonusgometrics

import (
        "github.com/circonus-labs/circonusllhist"
)

// Reset removes all existing counters and gauges.
func (m *CirconusMetrics) Reset() <span class="cov1" title="1">{
        m.cm.Lock()
        defer m.cm.Unlock()

        m.cfm.Lock()
        defer m.cfm.Unlock()

        m.gm.Lock()
        defer m.gm.Unlock()

        m.gfm.Lock()
        defer m.gfm.Unlock()

        m.hm.Lock()
        defer m.hm.Unlock()

        m.tm.Lock()
        defer m.tm.Unlock()

        m.tfm.Lock()
        defer m.tfm.Unlock()

        m.counters = make(map[string]uint64)
        m.counterFuncs = make(map[string]func() uint64)
        m.gauges = make(map[string]string)
        m.gaugeFuncs = make(map[string]func() int64)
        m.histograms = make(map[string]*Histogram)
        m.text = make(map[string]string)
        m.textFuncs = make(map[string]func() string)
}</span>

// snapshot returns a copy of the values of all registered counters and gauges.
func (m *CirconusMetrics) snapshot() (c map[string]uint64, g map[string]string, h map[string]*circonusllhist.Histogram, t map[string]string) <span class="cov10" title="12">{
        c = m.snapCounters()
        g = m.snapGauges()
        h = m.snapHistograms()
        t = m.snapText()

        return
}</span>

func (m *CirconusMetrics) snapCounters() map[string]uint64 <span class="cov10" title="12">{
        m.cm.Lock()
        defer m.cm.Unlock()
        m.cfm.Lock()
        defer m.cfm.Unlock()

        c := make(map[string]uint64, len(m.counters)+len(m.counterFuncs))

        for n, v := range m.counters </span><span class="cov4" title="3">{
                c[n] = v
        }</span>
        <span class="cov10" title="12">if m.resetCounters &amp;&amp; len(c) &gt; 0 </span><span class="cov4" title="3">{
                m.counters = make(map[string]uint64)
        }</span>

        <span class="cov10" title="12">for n, f := range m.counterFuncs </span><span class="cov0" title="0">{
                c[n] = f()
        }</span>
        <span class="cov10" title="12">if m.resetCounters &amp;&amp; len(c) &gt; 0 </span><span class="cov4" title="3">{
                m.counterFuncs = make(map[string]func() uint64)
        }</span>

        <span class="cov10" title="12">return c</span>
}

func (m *CirconusMetrics) snapGauges() map[string]string <span class="cov10" title="12">{
        m.gm.Lock()
        defer m.gm.Unlock()
        m.gfm.Lock()
        defer m.gfm.Unlock()

        g := make(map[string]string, len(m.gauges)+len(m.gaugeFuncs))

        for n, v := range m.gauges </span><span class="cov4" title="3">{
                g[n] = v
        }</span>
        <span class="cov10" title="12">if m.resetGauges &amp;&amp; len(g) &gt; 0 </span><span class="cov4" title="3">{
                m.gauges = make(map[string]string)
        }</span>

        <span class="cov10" title="12">for n, f := range m.gaugeFuncs </span><span class="cov0" title="0">{
                g[n] = m.gaugeValString(f())
        }</span>
        <span class="cov10" title="12">if m.resetGauges &amp;&amp; len(g) &gt; 0 </span><span class="cov4" title="3">{
                m.gaugeFuncs = make(map[string]func() int64)
        }</span>

        <span class="cov10" title="12">return g</span>
}

func (m *CirconusMetrics) snapHistograms() map[string]*circonusllhist.Histogram <span class="cov10" title="12">{
        m.hm.Lock()
        defer m.hm.Unlock()

        h := make(map[string]*circonusllhist.Histogram, len(m.histograms))

        for n, hist := range m.histograms </span><span class="cov4" title="3">{
                hist.rw.Lock()
                h[n] = hist.hist.CopyAndReset()
                hist.rw.Unlock()
        }</span>
        <span class="cov10" title="12">if m.resetHistograms &amp;&amp; len(h) &gt; 0 </span><span class="cov4" title="3">{
                m.histograms = make(map[string]*Histogram)
        }</span>

        <span class="cov10" title="12">return h</span>
}

func (m *CirconusMetrics) snapText() map[string]string <span class="cov10" title="12">{
        m.tm.Lock()
        defer m.tm.Unlock()
        m.tfm.Lock()
        defer m.tfm.Unlock()

        t := make(map[string]string, len(m.text)+len(m.textFuncs))

        for n, v := range m.text </span><span class="cov4" title="3">{
                t[n] = v
        }</span>
        <span class="cov10" title="12">if m.resetText &amp;&amp; len(t) &gt; 0 </span><span class="cov4" title="3">{
                m.text = make(map[string]string)
        }</span>

        <span class="cov10" title="12">for n, f := range m.textFuncs </span><span class="cov0" title="0">{
                t[n] = f()
        }</span>
        <span class="cov10" title="12">if m.resetText &amp;&amp; len(t) &gt; 0 </span><span class="cov4" title="3">{
                m.textFuncs = make(map[string]func() string)
        }</span>

        <span class="cov10" title="12">return t</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
